/* tslint:disable */
/* eslint-disable */
/*
Twitter API v2

Twitter API v2 available endpoints

The version of the OpenAPI document: 2.62


NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
import { setOAuthToObject } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { AddOrDeleteRulesRequest } from '../models';
// @ts-ignore
import { AddOrDeleteRulesResponse } from '../models';
// @ts-ignore
import { DeleteRulesRequestDelete } from '../models';
// @ts-ignore
import { FilteredStreamingTweetResponse } from '../models';
// @ts-ignore
import { Get2ListsIdTweetsResponse } from '../models';
// @ts-ignore
import { Get2SpacesIdBuyersResponse } from '../models';
// @ts-ignore
import { Get2SpacesIdTweetsResponse } from '../models';
// @ts-ignore
import { Get2TweetsCountsAllResponse } from '../models';
// @ts-ignore
import { Get2TweetsCountsRecentResponse } from '../models';
// @ts-ignore
import { Get2TweetsIdQuoteTweetsResponse } from '../models';
// @ts-ignore
import { Get2TweetsIdResponse } from '../models';
// @ts-ignore
import { Get2TweetsResponse } from '../models';
// @ts-ignore
import { Get2TweetsSample10StreamResponse } from '../models';
// @ts-ignore
import { Get2TweetsSearchAllResponse } from '../models';
// @ts-ignore
import { Get2TweetsSearchRecentResponse } from '../models';
// @ts-ignore
import { Get2UsersIdLikedTweetsResponse } from '../models';
// @ts-ignore
import { Get2UsersIdMentionsResponse } from '../models';
// @ts-ignore
import { Get2UsersIdTimelinesReverseChronologicalResponse } from '../models';
// @ts-ignore
import { Get2UsersIdTweetsResponse } from '../models';
// @ts-ignore
import { Problem } from '../models';
// @ts-ignore
import { RuleNoId } from '../models';
// @ts-ignore
import { RulesLookupResponse } from '../models';
// @ts-ignore
import { StreamingTweetResponse } from '../models';
// @ts-ignore
import { TweetCreateRequest } from '../models';
// @ts-ignore
import { TweetCreateRequestGeo } from '../models';
// @ts-ignore
import { TweetCreateRequestMedia } from '../models';
// @ts-ignore
import { TweetCreateRequestPoll } from '../models';
// @ts-ignore
import { TweetCreateRequestReply } from '../models';
// @ts-ignore
import { TweetCreateResponse } from '../models';
// @ts-ignore
import { TweetDeleteResponse } from '../models';
// @ts-ignore
import { TweetHideRequest } from '../models';
// @ts-ignore
import { TweetHideResponse } from '../models';
// @ts-ignore
import { UsersLikesCreateRequest } from '../models';
// @ts-ignore
import { UsersLikesCreateResponse } from '../models';
// @ts-ignore
import { UsersLikesDeleteResponse } from '../models';
// @ts-ignore
import { UsersRetweetsCreateRequest } from '../models';
// @ts-ignore
import { UsersRetweetsCreateResponse } from '../models';
// @ts-ignore
import { UsersRetweetsDeleteResponse } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * TweetsApi - axios parameter creator
 * @export
 */
export const TweetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add or delete rules from a User\'s active rule set. Users can provide unique, optionally tagged rules to add. Users can delete their entire rule set or a subset specified by rule ids or values.
         * @summary Add/Delete rules
         * @param {AddOrDeleteRulesRequest} addOrDeleteRulesRequest 
         * @param {boolean} [dryRun] Dry Run can be used with both the add and delete action, with the expected result given, but without actually taking any action in the system (meaning the end state will always be as it was when the request was submitted). This is particularly useful to validate rule changes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrDeleteRules: async (addOrDeleteRulesRequest: AddOrDeleteRulesRequest, dryRun?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addOrDeleteRulesRequest' is not null or undefined
            assertParamExists('addOrDeleteRules', 'addOrDeleteRulesRequest', addOrDeleteRulesRequest)
            const localVarPath = `/2/tweets/search/stream/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            if (dryRun !== undefined) {
                localVarQueryParameter['dry_run'] = dryRun;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: addOrDeleteRulesRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/2/tweets/search/stream/rules',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(addOrDeleteRulesRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Causes the User to create a Tweet under the authorized account.
         * @summary Creation of a Tweet
         * @param {TweetCreateRequest} tweetCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTweet: async (tweetCreateRequest: TweetCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tweetCreateRequest' is not null or undefined
            assertParamExists('createTweet', 'tweetCreateRequest', tweetCreateRequest)
            const localVarPath = `/2/tweets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["tweet.read", "tweet.write", "users.read"], configuration)
            // authentication UserToken required

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: tweetCreateRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/2/tweets',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(tweetCreateRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete specified Tweet (in the path) by ID.
         * @summary Tweet delete by Tweet ID
         * @param {string} id The ID of the Tweet to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteById: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteById', 'id', id)
            const localVarPath = `/2/tweets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["tweet.read", "tweet.write", "users.read"], configuration)
            // authentication UserToken required

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/2/tweets/{id}',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of Users who purchased a ticket to the given space
         * @summary Retrieve the list of Users who purchased a ticket to the given space
         * @param {string} id The ID of the Space to be retrieved.
         * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
         * @param {number} [maxResults] The maximum number of results.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBuyersList: async (id: string, paginationToken?: string, maxResults?: number, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getBuyersList', 'id', id)
            const localVarPath = `/2/spaces/{id}/buyers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["space.read", "tweet.read", "users.read"], configuration)
            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination_token'] = paginationToken;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/2/spaces/{id}/buyers',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Streams Tweets matching the stream\'s active rule set.
         * @summary Filtered stream
         * @param {number} [backfillMinutes] The number of minutes of backfill requested.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided.
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilteredStream: async (backfillMinutes?: number, startTime?: string, endTime?: string, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/2/tweets/search/stream`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            if (backfillMinutes !== undefined) {
                localVarQueryParameter['backfill_minutes'] = backfillMinutes;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = (startTime as any instanceof Date) ?
                    (startTime as any).toISOString() :
                    startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = (endTime as any instanceof Date) ?
                    (endTime as any).toISOString() :
                    endTime;
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (mediaFields) {
                localVarQueryParameter['media.fields'] = Array.from(mediaFields).join(COLLECTION_FORMATS.csv);
            }

            if (pollFields) {
                localVarQueryParameter['poll.fields'] = Array.from(pollFields).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (placeFields) {
                localVarQueryParameter['place.fields'] = Array.from(placeFields).join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/2/tweets/search/stream',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Streams 100% of public Tweets.
         * @summary Firehose stream
         * @param {number} partition The partition number.
         * @param {number} [backfillMinutes] The number of minutes of backfill requested.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Tweets will be provided.
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirehoseStream: async (partition: number, backfillMinutes?: number, startTime?: string, endTime?: string, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partition' is not null or undefined
            assertParamExists('getFirehoseStream', 'partition', partition)
            const localVarPath = `/2/tweets/firehose/stream`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            if (backfillMinutes !== undefined) {
                localVarQueryParameter['backfill_minutes'] = backfillMinutes;
            }

            if (partition !== undefined) {
                localVarQueryParameter['partition'] = partition;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = (startTime as any instanceof Date) ?
                    (startTime as any).toISOString() :
                    startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = (endTime as any instanceof Date) ?
                    (endTime as any).toISOString() :
                    endTime;
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (mediaFields) {
                localVarQueryParameter['media.fields'] = Array.from(mediaFields).join(COLLECTION_FORMATS.csv);
            }

            if (pollFields) {
                localVarQueryParameter['poll.fields'] = Array.from(pollFields).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (placeFields) {
                localVarQueryParameter['place.fields'] = Array.from(placeFields).join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/2/tweets/firehose/stream',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of Tweets liked by the provided User ID
         * @summary Returns Tweet objects liked by the provided User ID
         * @param {string} id The ID of the User to lookup.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLikedTweets: async (id: string, maxResults?: number, paginationToken?: string, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getLikedTweets', 'id', id)
            const localVarPath = `/2/users/{id}/liked_tweets`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["like.read", "tweet.read", "users.read"], configuration)
            // authentication UserToken required
            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination_token'] = paginationToken;
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (mediaFields) {
                localVarQueryParameter['media.fields'] = Array.from(mediaFields).join(COLLECTION_FORMATS.csv);
            }

            if (pollFields) {
                localVarQueryParameter['poll.fields'] = Array.from(pollFields).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (placeFields) {
                localVarQueryParameter['place.fields'] = Array.from(placeFields).join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/2/users/{id}/liked_tweets',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns Tweet objects that mention username associated to the provided User ID
         * @summary User mention timeline by User ID
         * @param {string} id The ID of the User to lookup.
         * @param {string} [sinceId] The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
         * @param {string} [untilId] The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMentionsById: async (id: string, sinceId?: string, untilId?: string, maxResults?: number, paginationToken?: string, startTime?: string, endTime?: string, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getMentionsById', 'id', id)
            const localVarPath = `/2/users/{id}/mentions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["tweet.read", "users.read"], configuration)
            // authentication UserToken required
            if (sinceId !== undefined) {
                localVarQueryParameter['since_id'] = sinceId;
            }

            if (untilId !== undefined) {
                localVarQueryParameter['until_id'] = untilId;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination_token'] = paginationToken;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = (startTime as any instanceof Date) ?
                    (startTime as any).toISOString() :
                    startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = (endTime as any instanceof Date) ?
                    (endTime as any).toISOString() :
                    endTime;
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (mediaFields) {
                localVarQueryParameter['media.fields'] = Array.from(mediaFields).join(COLLECTION_FORMATS.csv);
            }

            if (pollFields) {
                localVarQueryParameter['poll.fields'] = Array.from(pollFields).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (placeFields) {
                localVarQueryParameter['place.fields'] = Array.from(placeFields).join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/2/users/{id}/mentions',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a variety of information about each Tweet that quotes the Tweet specified by the requested ID.
         * @summary Retrieve Tweets that quote a Tweet.
         * @param {string} id A single Tweet ID.
         * @param {number} [maxResults] The maximum number of results to be returned.
         * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
         * @param {Set<'replies' | 'retweets'>} [exclude] The set of entities to exclude (e.g. \&#39;replies\&#39; or \&#39;retweets\&#39;).
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuoteTweets: async (id: string, maxResults?: number, paginationToken?: string, exclude?: Set<'replies' | 'retweets'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getQuoteTweets', 'id', id)
            const localVarPath = `/2/tweets/{id}/quote_tweets`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["tweet.read", "users.read"], configuration)
            // authentication UserToken required
            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination_token'] = paginationToken;
            }

            if (exclude) {
                localVarQueryParameter['exclude'] = Array.from(exclude).join(COLLECTION_FORMATS.csv);
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (mediaFields) {
                localVarQueryParameter['media.fields'] = Array.from(mediaFields).join(COLLECTION_FORMATS.csv);
            }

            if (pollFields) {
                localVarQueryParameter['poll.fields'] = Array.from(pollFields).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (placeFields) {
                localVarQueryParameter['place.fields'] = Array.from(placeFields).join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/2/tweets/{id}/quote_tweets',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns Tweet Counts from the last 7 days that match a search query.
         * @summary Recent search counts
         * @param {string} query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
         * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
         * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
         * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
         * @param {'minute' | 'hour' | 'day'} [granularity] The granularity for the search counts results.
         * @param {Set<'end' | 'start' | 'tweet_count'>} [searchCountFields] A comma separated list of SearchCount fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentTweetCounts: async (query: string, startTime?: string, endTime?: string, sinceId?: string, untilId?: string, nextToken?: string, paginationToken?: string, granularity?: 'minute' | 'hour' | 'day', searchCountFields?: Set<'end' | 'start' | 'tweet_count'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            assertParamExists('getRecentTweetCounts', 'query', query)
            const localVarPath = `/2/tweets/counts/recent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = (startTime as any instanceof Date) ?
                    (startTime as any).toISOString() :
                    startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = (endTime as any instanceof Date) ?
                    (endTime as any).toISOString() :
                    endTime;
            }

            if (sinceId !== undefined) {
                localVarQueryParameter['since_id'] = sinceId;
            }

            if (untilId !== undefined) {
                localVarQueryParameter['until_id'] = untilId;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination_token'] = paginationToken;
            }

            if (granularity !== undefined) {
                localVarQueryParameter['granularity'] = granularity;
            }

            if (searchCountFields) {
                localVarQueryParameter['search_count.fields'] = Array.from(searchCountFields).join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/2/tweets/counts/recent',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns Tweets from the last 7 days that match a search query.
         * @summary Recent search
         * @param {string} query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
         * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
         * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
         * @param {number} [maxResults] The maximum number of search results to be returned by a request.
         * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
         * @param {'recency' | 'relevancy'} [sortOrder] This order in which to return results.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentTweets: async (query: string, startTime?: string, endTime?: string, sinceId?: string, untilId?: string, maxResults?: number, nextToken?: string, paginationToken?: string, sortOrder?: 'recency' | 'relevancy', tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            assertParamExists('getRecentTweets', 'query', query)
            const localVarPath = `/2/tweets/search/recent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["tweet.read", "users.read"], configuration)
            // authentication UserToken required
            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = (startTime as any instanceof Date) ?
                    (startTime as any).toISOString() :
                    startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = (endTime as any instanceof Date) ?
                    (endTime as any).toISOString() :
                    endTime;
            }

            if (sinceId !== undefined) {
                localVarQueryParameter['since_id'] = sinceId;
            }

            if (untilId !== undefined) {
                localVarQueryParameter['until_id'] = untilId;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination_token'] = paginationToken;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (mediaFields) {
                localVarQueryParameter['media.fields'] = Array.from(mediaFields).join(COLLECTION_FORMATS.csv);
            }

            if (pollFields) {
                localVarQueryParameter['poll.fields'] = Array.from(pollFields).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (placeFields) {
                localVarQueryParameter['place.fields'] = Array.from(placeFields).join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/2/tweets/search/recent',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns Tweet Counts that match a search query.
         * @summary Full archive search counts
         * @param {string} query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
         * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
         * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
         * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
         * @param {'minute' | 'hour' | 'day'} [granularity] The granularity for the search counts results.
         * @param {Set<'end' | 'start' | 'tweet_count'>} [searchCountFields] A comma separated list of SearchCount fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTweetCounts: async (query: string, startTime?: string, endTime?: string, sinceId?: string, untilId?: string, nextToken?: string, paginationToken?: string, granularity?: 'minute' | 'hour' | 'day', searchCountFields?: Set<'end' | 'start' | 'tweet_count'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            assertParamExists('getTweetCounts', 'query', query)
            const localVarPath = `/2/tweets/counts/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = (startTime as any instanceof Date) ?
                    (startTime as any).toISOString() :
                    startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = (endTime as any instanceof Date) ?
                    (endTime as any).toISOString() :
                    endTime;
            }

            if (sinceId !== undefined) {
                localVarQueryParameter['since_id'] = sinceId;
            }

            if (untilId !== undefined) {
                localVarQueryParameter['until_id'] = untilId;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination_token'] = paginationToken;
            }

            if (granularity !== undefined) {
                localVarQueryParameter['granularity'] = granularity;
            }

            if (searchCountFields) {
                localVarQueryParameter['search_count.fields'] = Array.from(searchCountFields).join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/2/tweets/counts/all',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves Tweets shared in the specified Space.
         * @summary Retrieve Tweets from a Space.
         * @param {string} id The ID of the Space to be retrieved.
         * @param {number} [maxResults] The number of Tweets to fetch from the provided space. If not provided, the value will default to the maximum of 100.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTweets: async (id: string, maxResults?: number, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTweets', 'id', id)
            const localVarPath = `/2/spaces/{id}/tweets`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["space.read", "tweet.read", "users.read"], configuration)
            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (mediaFields) {
                localVarQueryParameter['media.fields'] = Array.from(mediaFields).join(COLLECTION_FORMATS.csv);
            }

            if (pollFields) {
                localVarQueryParameter['poll.fields'] = Array.from(pollFields).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (placeFields) {
                localVarQueryParameter['place.fields'] = Array.from(placeFields).join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/2/spaces/{id}/tweets',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns Tweet objects that appears in the provided User ID\'s home timeline
         * @summary User home timeline by User ID
         * @param {string} id The ID of the authenticated source User to list Reverse Chronological Timeline Tweets of.
         * @param {string} [sinceId] The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
         * @param {string} [untilId] The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
         * @param {Set<'replies' | 'retweets'>} [exclude] The set of entities to exclude (e.g. \&#39;replies\&#39; or \&#39;retweets\&#39;).
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserHomeTimeline: async (id: string, sinceId?: string, untilId?: string, maxResults?: number, paginationToken?: string, exclude?: Set<'replies' | 'retweets'>, startTime?: string, endTime?: string, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUserHomeTimeline', 'id', id)
            const localVarPath = `/2/users/{id}/timelines/reverse_chronological`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["tweet.read", "users.read"], configuration)
            // authentication UserToken required
            if (sinceId !== undefined) {
                localVarQueryParameter['since_id'] = sinceId;
            }

            if (untilId !== undefined) {
                localVarQueryParameter['until_id'] = untilId;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination_token'] = paginationToken;
            }

            if (exclude) {
                localVarQueryParameter['exclude'] = Array.from(exclude).join(COLLECTION_FORMATS.csv);
            }

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = (startTime as any instanceof Date) ?
                    (startTime as any).toISOString() :
                    startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = (endTime as any instanceof Date) ?
                    (endTime as any).toISOString() :
                    endTime;
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (mediaFields) {
                localVarQueryParameter['media.fields'] = Array.from(mediaFields).join(COLLECTION_FORMATS.csv);
            }

            if (pollFields) {
                localVarQueryParameter['poll.fields'] = Array.from(pollFields).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (placeFields) {
                localVarQueryParameter['place.fields'] = Array.from(placeFields).join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/2/users/{id}/timelines/reverse_chronological',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Hides or unhides a reply to an owned conversation.
         * @summary Hide replies
         * @param {string} tweetId The ID of the reply that you want to hide or unhide.
         * @param {TweetHideRequest} [tweetHideRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hideReply: async (tweetId: string, tweetHideRequest?: TweetHideRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tweetId' is not null or undefined
            assertParamExists('hideReply', 'tweetId', tweetId)
            const localVarPath = `/2/tweets/{tweet_id}/hidden`
                .replace(`{${"tweet_id"}}`, encodeURIComponent(String(tweetId !== undefined ? tweetId : `-tweet_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["tweet.moderate.write", "tweet.read", "users.read"], configuration)
            // authentication UserToken required

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: tweetHideRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/2/tweets/{tweet_id}/hidden',
                httpMethod: 'PUT'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(tweetHideRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Causes the User (in the path) to like the specified Tweet. The User in the path must match the User context authorizing the request.
         * @summary Causes the User (in the path) to like the specified Tweet
         * @param {string} id The ID of the authenticated source User that is requesting to like the Tweet.
         * @param {UsersLikesCreateRequest} [usersLikesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        likeTweet: async (id: string, usersLikesCreateRequest?: UsersLikesCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('likeTweet', 'id', id)
            const localVarPath = `/2/users/{id}/likes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["like.write", "tweet.read", "users.read"], configuration)
            // authentication UserToken required

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: usersLikesCreateRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/2/users/{id}/likes',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(usersLikesCreateRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of Tweets associated with the provided List ID.
         * @summary List Tweets timeline by List ID.
         * @param {string} id The ID of the List.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listByListId: async (id: string, maxResults?: number, paginationToken?: string, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listByListId', 'id', id)
            const localVarPath = `/2/lists/{id}/tweets`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["list.read", "tweet.read", "users.read"], configuration)
            // authentication UserToken required
            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination_token'] = paginationToken;
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (mediaFields) {
                localVarQueryParameter['media.fields'] = Array.from(mediaFields).join(COLLECTION_FORMATS.csv);
            }

            if (pollFields) {
                localVarQueryParameter['poll.fields'] = Array.from(pollFields).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (placeFields) {
                localVarQueryParameter['place.fields'] = Array.from(placeFields).join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/2/lists/{id}/tweets',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of Tweets authored by the provided User ID
         * @summary User Tweets timeline by User ID
         * @param {string} id The ID of the User to lookup.
         * @param {string} [sinceId] The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
         * @param {string} [untilId] The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
         * @param {Set<'replies' | 'retweets'>} [exclude] The set of entities to exclude (e.g. \&#39;replies\&#39; or \&#39;retweets\&#39;).
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listByUserId: async (id: string, sinceId?: string, untilId?: string, maxResults?: number, paginationToken?: string, exclude?: Set<'replies' | 'retweets'>, startTime?: string, endTime?: string, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listByUserId', 'id', id)
            const localVarPath = `/2/users/{id}/tweets`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["tweet.read", "users.read"], configuration)
            // authentication UserToken required
            if (sinceId !== undefined) {
                localVarQueryParameter['since_id'] = sinceId;
            }

            if (untilId !== undefined) {
                localVarQueryParameter['until_id'] = untilId;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination_token'] = paginationToken;
            }

            if (exclude) {
                localVarQueryParameter['exclude'] = Array.from(exclude).join(COLLECTION_FORMATS.csv);
            }

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = (startTime as any instanceof Date) ?
                    (startTime as any).toISOString() :
                    startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = (endTime as any instanceof Date) ?
                    (endTime as any).toISOString() :
                    endTime;
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (mediaFields) {
                localVarQueryParameter['media.fields'] = Array.from(mediaFields).join(COLLECTION_FORMATS.csv);
            }

            if (pollFields) {
                localVarQueryParameter['poll.fields'] = Array.from(pollFields).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (placeFields) {
                localVarQueryParameter['place.fields'] = Array.from(placeFields).join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/2/users/{id}/tweets',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a variety of information about the Tweet specified by the requested ID.
         * @summary Tweet lookup by Tweet ID
         * @param {string} id A single Tweet ID.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupById: async (id: string, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('lookupById', 'id', id)
            const localVarPath = `/2/tweets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["tweet.read", "users.read"], configuration)
            // authentication UserToken required
            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (mediaFields) {
                localVarQueryParameter['media.fields'] = Array.from(mediaFields).join(COLLECTION_FORMATS.csv);
            }

            if (pollFields) {
                localVarQueryParameter['poll.fields'] = Array.from(pollFields).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (placeFields) {
                localVarQueryParameter['place.fields'] = Array.from(placeFields).join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/2/tweets/{id}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a variety of information about the Tweet specified by the requested ID.
         * @summary Tweet lookup by Tweet IDs
         * @param {Array<string>} ids A comma separated list of Tweet IDs. Up to 100 are allowed in a single request.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupByTweetIds: async (ids: Array<string>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('lookupByTweetIds', 'ids', ids)
            const localVarPath = `/2/tweets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["tweet.read", "users.read"], configuration)
            // authentication UserToken required
            if (ids) {
                localVarQueryParameter['ids'] = ids.join(COLLECTION_FORMATS.csv);
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (mediaFields) {
                localVarQueryParameter['media.fields'] = Array.from(mediaFields).join(COLLECTION_FORMATS.csv);
            }

            if (pollFields) {
                localVarQueryParameter['poll.fields'] = Array.from(pollFields).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (placeFields) {
                localVarQueryParameter['place.fields'] = Array.from(placeFields).join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/2/tweets',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Causes the User (in the path) to retweet the specified Tweet. The User in the path must match the User context authorizing the request.
         * @summary Causes the User (in the path) to retweet the specified Tweet.
         * @param {string} id The ID of the authenticated source User that is requesting to retweet the Tweet.
         * @param {UsersRetweetsCreateRequest} [usersRetweetsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retweetTweetById: async (id: string, usersRetweetsCreateRequest?: UsersRetweetsCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retweetTweetById', 'id', id)
            const localVarPath = `/2/users/{id}/retweets`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["tweet.read", "tweet.write", "users.read"], configuration)
            // authentication UserToken required

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: usersRetweetsCreateRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/2/users/{id}/retweets',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(usersRetweetsCreateRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns Tweets that match a search query.
         * @summary Full-archive search
         * @param {string} query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
         * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
         * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
         * @param {number} [maxResults] The maximum number of search results to be returned by a request.
         * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
         * @param {'recency' | 'relevancy'} [sortOrder] This order in which to return results.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAll: async (query: string, startTime?: string, endTime?: string, sinceId?: string, untilId?: string, maxResults?: number, nextToken?: string, paginationToken?: string, sortOrder?: 'recency' | 'relevancy', tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            assertParamExists('searchAll', 'query', query)
            const localVarPath = `/2/tweets/search/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = (startTime as any instanceof Date) ?
                    (startTime as any).toISOString() :
                    startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = (endTime as any instanceof Date) ?
                    (endTime as any).toISOString() :
                    endTime;
            }

            if (sinceId !== undefined) {
                localVarQueryParameter['since_id'] = sinceId;
            }

            if (untilId !== undefined) {
                localVarQueryParameter['until_id'] = untilId;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination_token'] = paginationToken;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (mediaFields) {
                localVarQueryParameter['media.fields'] = Array.from(mediaFields).join(COLLECTION_FORMATS.csv);
            }

            if (pollFields) {
                localVarQueryParameter['poll.fields'] = Array.from(pollFields).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (placeFields) {
                localVarQueryParameter['place.fields'] = Array.from(placeFields).join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/2/tweets/search/all',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns rules from a User\'s active rule set. Users can fetch all of their rules or a subset, specified by the provided rule ids.
         * @summary Rules lookup
         * @param {Array<string>} [ids] A comma-separated list of Rule IDs.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This value is populated by passing the \&#39;next_token\&#39; returned in a request to paginate through results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchStreamRules: async (ids?: Array<string>, maxResults?: number, paginationToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/2/tweets/search/stream/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination_token'] = paginationToken;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/2/tweets/search/stream/rules',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Streams a deterministic 1% of public Tweets.
         * @summary Sample stream
         * @param {number} [backfillMinutes] The number of minutes of backfill requested.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamSample: async (backfillMinutes?: number, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/2/tweets/sample/stream`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            if (backfillMinutes !== undefined) {
                localVarQueryParameter['backfill_minutes'] = backfillMinutes;
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (mediaFields) {
                localVarQueryParameter['media.fields'] = Array.from(mediaFields).join(COLLECTION_FORMATS.csv);
            }

            if (pollFields) {
                localVarQueryParameter['poll.fields'] = Array.from(pollFields).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (placeFields) {
                localVarQueryParameter['place.fields'] = Array.from(placeFields).join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/2/tweets/sample/stream',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Streams a deterministic 10% of public Tweets.
         * @summary Sample 10% stream
         * @param {number} partition The partition number.
         * @param {number} [backfillMinutes] The number of minutes of backfill requested.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Tweets will be provided.
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamSample10: async (partition: number, backfillMinutes?: number, startTime?: string, endTime?: string, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partition' is not null or undefined
            assertParamExists('streamSample10', 'partition', partition)
            const localVarPath = `/2/tweets/sample10/stream`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            if (backfillMinutes !== undefined) {
                localVarQueryParameter['backfill_minutes'] = backfillMinutes;
            }

            if (partition !== undefined) {
                localVarQueryParameter['partition'] = partition;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = (startTime as any instanceof Date) ?
                    (startTime as any).toISOString() :
                    startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = (endTime as any instanceof Date) ?
                    (endTime as any).toISOString() :
                    endTime;
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (mediaFields) {
                localVarQueryParameter['media.fields'] = Array.from(mediaFields).join(COLLECTION_FORMATS.csv);
            }

            if (pollFields) {
                localVarQueryParameter['poll.fields'] = Array.from(pollFields).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (placeFields) {
                localVarQueryParameter['place.fields'] = Array.from(placeFields).join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/2/tweets/sample10/stream',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Causes the User (in the path) to unlike the specified Tweet. The User must match the User context authorizing the request
         * @summary Causes the User (in the path) to unlike the specified Tweet
         * @param {string} id The ID of the authenticated source User that is requesting to unlike the Tweet.
         * @param {string} tweetId The ID of the Tweet that the User is requesting to unlike.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlikeTweetById: async (id: string, tweetId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('unlikeTweetById', 'id', id)
            // verify required parameter 'tweetId' is not null or undefined
            assertParamExists('unlikeTweetById', 'tweetId', tweetId)
            const localVarPath = `/2/users/{id}/likes/{tweet_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)))
                .replace(`{${"tweet_id"}}`, encodeURIComponent(String(tweetId !== undefined ? tweetId : `-tweet_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["like.write", "tweet.read", "users.read"], configuration)
            // authentication UserToken required

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/2/users/{id}/likes/{tweet_id}',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Causes the User (in the path) to unretweet the specified Tweet. The User must match the User context authorizing the request
         * @summary Causes the User (in the path) to unretweet the specified Tweet
         * @param {string} id The ID of the authenticated source User that is requesting to retweet the Tweet.
         * @param {string} sourceTweetId The ID of the Tweet that the User is requesting to unretweet.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unretweetById: async (id: string, sourceTweetId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('unretweetById', 'id', id)
            // verify required parameter 'sourceTweetId' is not null or undefined
            assertParamExists('unretweetById', 'sourceTweetId', sourceTweetId)
            const localVarPath = `/2/users/{id}/retweets/{source_tweet_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)))
                .replace(`{${"source_tweet_id"}}`, encodeURIComponent(String(sourceTweetId !== undefined ? sourceTweetId : `-source_tweet_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["tweet.read", "tweet.write", "users.read"], configuration)
            // authentication UserToken required

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/2/users/{id}/retweets/{source_tweet_id}',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TweetsApi - functional programming interface
 * @export
 */
export const TweetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TweetsApiAxiosParamCreator(configuration)
    return {
        /**
         * Add or delete rules from a User\'s active rule set. Users can provide unique, optionally tagged rules to add. Users can delete their entire rule set or a subset specified by rule ids or values.
         * @summary Add/Delete rules
         * @param {TweetsApiAddOrDeleteRulesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOrDeleteRules(requestParameters: TweetsApiAddOrDeleteRulesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddOrDeleteRulesResponse>> {
            const addOrDeleteRulesRequest: AddOrDeleteRulesRequest = requestParameters;
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOrDeleteRules(addOrDeleteRulesRequest, requestParameters.dryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Causes the User to create a Tweet under the authorized account.
         * @summary Creation of a Tweet
         * @param {TweetsApiCreateTweetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTweet(requestParameters: TweetsApiCreateTweetRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TweetCreateResponse>> {
            const tweetCreateRequest: TweetCreateRequest = {
                card_uri: requestParameters.card_uri,
                direct_message_deep_link: requestParameters.direct_message_deep_link,
                for_super_followers_only: requestParameters.for_super_followers_only,
                geo: requestParameters.geo,
                media: requestParameters.media,
                nullcast: requestParameters.nullcast,
                poll: requestParameters.poll,
                quote_tweet_id: requestParameters.quote_tweet_id,
                reply: requestParameters.reply,
                reply_settings: requestParameters.reply_settings,
                text: requestParameters.text
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTweet(tweetCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete specified Tweet (in the path) by ID.
         * @summary Tweet delete by Tweet ID
         * @param {TweetsApiDeleteByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteById(requestParameters: TweetsApiDeleteByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TweetDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteById(requestParameters.id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of Users who purchased a ticket to the given space
         * @summary Retrieve the list of Users who purchased a ticket to the given space
         * @param {TweetsApiGetBuyersListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBuyersList(requestParameters: TweetsApiGetBuyersListRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2SpacesIdBuyersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBuyersList(requestParameters.id, requestParameters.paginationToken, requestParameters.maxResults, requestParameters.userFields, requestParameters.expansions, requestParameters.tweetFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Streams Tweets matching the stream\'s active rule set.
         * @summary Filtered stream
         * @param {TweetsApiGetFilteredStreamRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFilteredStream(requestParameters: TweetsApiGetFilteredStreamRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilteredStreamingTweetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFilteredStream(requestParameters.backfillMinutes, requestParameters.startTime, requestParameters.endTime, requestParameters.tweetFields, requestParameters.expansions, requestParameters.mediaFields, requestParameters.pollFields, requestParameters.userFields, requestParameters.placeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Streams 100% of public Tweets.
         * @summary Firehose stream
         * @param {TweetsApiGetFirehoseStreamRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFirehoseStream(requestParameters: TweetsApiGetFirehoseStreamRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StreamingTweetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFirehoseStream(requestParameters.partition, requestParameters.backfillMinutes, requestParameters.startTime, requestParameters.endTime, requestParameters.tweetFields, requestParameters.expansions, requestParameters.mediaFields, requestParameters.pollFields, requestParameters.userFields, requestParameters.placeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of Tweets liked by the provided User ID
         * @summary Returns Tweet objects liked by the provided User ID
         * @param {TweetsApiGetLikedTweetsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLikedTweets(requestParameters: TweetsApiGetLikedTweetsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2UsersIdLikedTweetsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLikedTweets(requestParameters.id, requestParameters.maxResults, requestParameters.paginationToken, requestParameters.tweetFields, requestParameters.expansions, requestParameters.mediaFields, requestParameters.pollFields, requestParameters.userFields, requestParameters.placeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns Tweet objects that mention username associated to the provided User ID
         * @summary User mention timeline by User ID
         * @param {TweetsApiGetMentionsByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMentionsById(requestParameters: TweetsApiGetMentionsByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2UsersIdMentionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMentionsById(requestParameters.id, requestParameters.sinceId, requestParameters.untilId, requestParameters.maxResults, requestParameters.paginationToken, requestParameters.startTime, requestParameters.endTime, requestParameters.tweetFields, requestParameters.expansions, requestParameters.mediaFields, requestParameters.pollFields, requestParameters.userFields, requestParameters.placeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a variety of information about each Tweet that quotes the Tweet specified by the requested ID.
         * @summary Retrieve Tweets that quote a Tweet.
         * @param {TweetsApiGetQuoteTweetsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQuoteTweets(requestParameters: TweetsApiGetQuoteTweetsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2TweetsIdQuoteTweetsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQuoteTweets(requestParameters.id, requestParameters.maxResults, requestParameters.paginationToken, requestParameters.exclude, requestParameters.tweetFields, requestParameters.expansions, requestParameters.mediaFields, requestParameters.pollFields, requestParameters.userFields, requestParameters.placeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns Tweet Counts from the last 7 days that match a search query.
         * @summary Recent search counts
         * @param {TweetsApiGetRecentTweetCountsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecentTweetCounts(requestParameters: TweetsApiGetRecentTweetCountsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2TweetsCountsRecentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecentTweetCounts(requestParameters.query, requestParameters.startTime, requestParameters.endTime, requestParameters.sinceId, requestParameters.untilId, requestParameters.nextToken, requestParameters.paginationToken, requestParameters.granularity, requestParameters.searchCountFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns Tweets from the last 7 days that match a search query.
         * @summary Recent search
         * @param {TweetsApiGetRecentTweetsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecentTweets(requestParameters: TweetsApiGetRecentTweetsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2TweetsSearchRecentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecentTweets(requestParameters.query, requestParameters.startTime, requestParameters.endTime, requestParameters.sinceId, requestParameters.untilId, requestParameters.maxResults, requestParameters.nextToken, requestParameters.paginationToken, requestParameters.sortOrder, requestParameters.tweetFields, requestParameters.expansions, requestParameters.mediaFields, requestParameters.pollFields, requestParameters.userFields, requestParameters.placeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns Tweet Counts that match a search query.
         * @summary Full archive search counts
         * @param {TweetsApiGetTweetCountsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTweetCounts(requestParameters: TweetsApiGetTweetCountsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2TweetsCountsAllResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTweetCounts(requestParameters.query, requestParameters.startTime, requestParameters.endTime, requestParameters.sinceId, requestParameters.untilId, requestParameters.nextToken, requestParameters.paginationToken, requestParameters.granularity, requestParameters.searchCountFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves Tweets shared in the specified Space.
         * @summary Retrieve Tweets from a Space.
         * @param {TweetsApiGetTweetsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTweets(requestParameters: TweetsApiGetTweetsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2SpacesIdTweetsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTweets(requestParameters.id, requestParameters.maxResults, requestParameters.tweetFields, requestParameters.expansions, requestParameters.mediaFields, requestParameters.pollFields, requestParameters.userFields, requestParameters.placeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns Tweet objects that appears in the provided User ID\'s home timeline
         * @summary User home timeline by User ID
         * @param {TweetsApiGetUserHomeTimelineRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserHomeTimeline(requestParameters: TweetsApiGetUserHomeTimelineRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2UsersIdTimelinesReverseChronologicalResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserHomeTimeline(requestParameters.id, requestParameters.sinceId, requestParameters.untilId, requestParameters.maxResults, requestParameters.paginationToken, requestParameters.exclude, requestParameters.startTime, requestParameters.endTime, requestParameters.tweetFields, requestParameters.expansions, requestParameters.mediaFields, requestParameters.pollFields, requestParameters.userFields, requestParameters.placeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Hides or unhides a reply to an owned conversation.
         * @summary Hide replies
         * @param {TweetsApiHideReplyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hideReply(requestParameters: TweetsApiHideReplyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TweetHideResponse>> {
            const tweetHideRequest: TweetHideRequest = {
                hidden: requestParameters.hidden
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.hideReply(requestParameters.tweetId, tweetHideRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Causes the User (in the path) to like the specified Tweet. The User in the path must match the User context authorizing the request.
         * @summary Causes the User (in the path) to like the specified Tweet
         * @param {TweetsApiLikeTweetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async likeTweet(requestParameters: TweetsApiLikeTweetRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersLikesCreateResponse>> {
            const usersLikesCreateRequest: UsersLikesCreateRequest = {
                tweet_id: requestParameters.tweet_id
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.likeTweet(requestParameters.id, usersLikesCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of Tweets associated with the provided List ID.
         * @summary List Tweets timeline by List ID.
         * @param {TweetsApiListByListIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listByListId(requestParameters: TweetsApiListByListIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2ListsIdTweetsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listByListId(requestParameters.id, requestParameters.maxResults, requestParameters.paginationToken, requestParameters.tweetFields, requestParameters.expansions, requestParameters.mediaFields, requestParameters.pollFields, requestParameters.userFields, requestParameters.placeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of Tweets authored by the provided User ID
         * @summary User Tweets timeline by User ID
         * @param {TweetsApiListByUserIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listByUserId(requestParameters: TweetsApiListByUserIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2UsersIdTweetsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listByUserId(requestParameters.id, requestParameters.sinceId, requestParameters.untilId, requestParameters.maxResults, requestParameters.paginationToken, requestParameters.exclude, requestParameters.startTime, requestParameters.endTime, requestParameters.tweetFields, requestParameters.expansions, requestParameters.mediaFields, requestParameters.pollFields, requestParameters.userFields, requestParameters.placeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a variety of information about the Tweet specified by the requested ID.
         * @summary Tweet lookup by Tweet ID
         * @param {TweetsApiLookupByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lookupById(requestParameters: TweetsApiLookupByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2TweetsIdResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupById(requestParameters.id, requestParameters.tweetFields, requestParameters.expansions, requestParameters.mediaFields, requestParameters.pollFields, requestParameters.userFields, requestParameters.placeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a variety of information about the Tweet specified by the requested ID.
         * @summary Tweet lookup by Tweet IDs
         * @param {TweetsApiLookupByTweetIdsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lookupByTweetIds(requestParameters: TweetsApiLookupByTweetIdsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2TweetsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupByTweetIds(requestParameters.ids, requestParameters.tweetFields, requestParameters.expansions, requestParameters.mediaFields, requestParameters.pollFields, requestParameters.userFields, requestParameters.placeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Causes the User (in the path) to retweet the specified Tweet. The User in the path must match the User context authorizing the request.
         * @summary Causes the User (in the path) to retweet the specified Tweet.
         * @param {TweetsApiRetweetTweetByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retweetTweetById(requestParameters: TweetsApiRetweetTweetByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersRetweetsCreateResponse>> {
            const usersRetweetsCreateRequest: UsersRetweetsCreateRequest = {
                tweet_id: requestParameters.tweet_id
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.retweetTweetById(requestParameters.id, usersRetweetsCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns Tweets that match a search query.
         * @summary Full-archive search
         * @param {TweetsApiSearchAllRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchAll(requestParameters: TweetsApiSearchAllRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2TweetsSearchAllResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchAll(requestParameters.query, requestParameters.startTime, requestParameters.endTime, requestParameters.sinceId, requestParameters.untilId, requestParameters.maxResults, requestParameters.nextToken, requestParameters.paginationToken, requestParameters.sortOrder, requestParameters.tweetFields, requestParameters.expansions, requestParameters.mediaFields, requestParameters.pollFields, requestParameters.userFields, requestParameters.placeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns rules from a User\'s active rule set. Users can fetch all of their rules or a subset, specified by the provided rule ids.
         * @summary Rules lookup
         * @param {TweetsApiSearchStreamRulesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchStreamRules(requestParameters: TweetsApiSearchStreamRulesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RulesLookupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchStreamRules(requestParameters.ids, requestParameters.maxResults, requestParameters.paginationToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Streams a deterministic 1% of public Tweets.
         * @summary Sample stream
         * @param {TweetsApiStreamSampleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async streamSample(requestParameters: TweetsApiStreamSampleRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StreamingTweetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.streamSample(requestParameters.backfillMinutes, requestParameters.tweetFields, requestParameters.expansions, requestParameters.mediaFields, requestParameters.pollFields, requestParameters.userFields, requestParameters.placeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Streams a deterministic 10% of public Tweets.
         * @summary Sample 10% stream
         * @param {TweetsApiStreamSample10Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async streamSample10(requestParameters: TweetsApiStreamSample10Request, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2TweetsSample10StreamResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.streamSample10(requestParameters.partition, requestParameters.backfillMinutes, requestParameters.startTime, requestParameters.endTime, requestParameters.tweetFields, requestParameters.expansions, requestParameters.mediaFields, requestParameters.pollFields, requestParameters.userFields, requestParameters.placeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Causes the User (in the path) to unlike the specified Tweet. The User must match the User context authorizing the request
         * @summary Causes the User (in the path) to unlike the specified Tweet
         * @param {TweetsApiUnlikeTweetByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlikeTweetById(requestParameters: TweetsApiUnlikeTweetByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersLikesDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlikeTweetById(requestParameters.id, requestParameters.tweetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Causes the User (in the path) to unretweet the specified Tweet. The User must match the User context authorizing the request
         * @summary Causes the User (in the path) to unretweet the specified Tweet
         * @param {TweetsApiUnretweetByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unretweetById(requestParameters: TweetsApiUnretweetByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersRetweetsDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unretweetById(requestParameters.id, requestParameters.sourceTweetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TweetsApi - factory interface
 * @export
 */
export const TweetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TweetsApiFp(configuration)
    return {
        /**
         * Add or delete rules from a User\'s active rule set. Users can provide unique, optionally tagged rules to add. Users can delete their entire rule set or a subset specified by rule ids or values.
         * @summary Add/Delete rules
         * @param {TweetsApiAddOrDeleteRulesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrDeleteRules(requestParameters: TweetsApiAddOrDeleteRulesRequest, options?: AxiosRequestConfig): AxiosPromise<AddOrDeleteRulesResponse> {
            return localVarFp.addOrDeleteRules(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Causes the User to create a Tweet under the authorized account.
         * @summary Creation of a Tweet
         * @param {TweetsApiCreateTweetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTweet(requestParameters: TweetsApiCreateTweetRequest, options?: AxiosRequestConfig): AxiosPromise<TweetCreateResponse> {
            return localVarFp.createTweet(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete specified Tweet (in the path) by ID.
         * @summary Tweet delete by Tweet ID
         * @param {TweetsApiDeleteByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteById(requestParameters: TweetsApiDeleteByIdRequest, options?: AxiosRequestConfig): AxiosPromise<TweetDeleteResponse> {
            return localVarFp.deleteById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of Users who purchased a ticket to the given space
         * @summary Retrieve the list of Users who purchased a ticket to the given space
         * @param {TweetsApiGetBuyersListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBuyersList(requestParameters: TweetsApiGetBuyersListRequest, options?: AxiosRequestConfig): AxiosPromise<Get2SpacesIdBuyersResponse> {
            return localVarFp.getBuyersList(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Streams Tweets matching the stream\'s active rule set.
         * @summary Filtered stream
         * @param {TweetsApiGetFilteredStreamRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilteredStream(requestParameters: TweetsApiGetFilteredStreamRequest = {}, options?: AxiosRequestConfig): AxiosPromise<FilteredStreamingTweetResponse> {
            return localVarFp.getFilteredStream(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Streams 100% of public Tweets.
         * @summary Firehose stream
         * @param {TweetsApiGetFirehoseStreamRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirehoseStream(requestParameters: TweetsApiGetFirehoseStreamRequest, options?: AxiosRequestConfig): AxiosPromise<StreamingTweetResponse> {
            return localVarFp.getFirehoseStream(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of Tweets liked by the provided User ID
         * @summary Returns Tweet objects liked by the provided User ID
         * @param {TweetsApiGetLikedTweetsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLikedTweets(requestParameters: TweetsApiGetLikedTweetsRequest, options?: AxiosRequestConfig): AxiosPromise<Get2UsersIdLikedTweetsResponse> {
            return localVarFp.getLikedTweets(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns Tweet objects that mention username associated to the provided User ID
         * @summary User mention timeline by User ID
         * @param {TweetsApiGetMentionsByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMentionsById(requestParameters: TweetsApiGetMentionsByIdRequest, options?: AxiosRequestConfig): AxiosPromise<Get2UsersIdMentionsResponse> {
            return localVarFp.getMentionsById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a variety of information about each Tweet that quotes the Tweet specified by the requested ID.
         * @summary Retrieve Tweets that quote a Tweet.
         * @param {TweetsApiGetQuoteTweetsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuoteTweets(requestParameters: TweetsApiGetQuoteTweetsRequest, options?: AxiosRequestConfig): AxiosPromise<Get2TweetsIdQuoteTweetsResponse> {
            return localVarFp.getQuoteTweets(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns Tweet Counts from the last 7 days that match a search query.
         * @summary Recent search counts
         * @param {TweetsApiGetRecentTweetCountsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentTweetCounts(requestParameters: TweetsApiGetRecentTweetCountsRequest, options?: AxiosRequestConfig): AxiosPromise<Get2TweetsCountsRecentResponse> {
            return localVarFp.getRecentTweetCounts(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns Tweets from the last 7 days that match a search query.
         * @summary Recent search
         * @param {TweetsApiGetRecentTweetsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentTweets(requestParameters: TweetsApiGetRecentTweetsRequest, options?: AxiosRequestConfig): AxiosPromise<Get2TweetsSearchRecentResponse> {
            return localVarFp.getRecentTweets(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns Tweet Counts that match a search query.
         * @summary Full archive search counts
         * @param {TweetsApiGetTweetCountsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTweetCounts(requestParameters: TweetsApiGetTweetCountsRequest, options?: AxiosRequestConfig): AxiosPromise<Get2TweetsCountsAllResponse> {
            return localVarFp.getTweetCounts(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves Tweets shared in the specified Space.
         * @summary Retrieve Tweets from a Space.
         * @param {TweetsApiGetTweetsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTweets(requestParameters: TweetsApiGetTweetsRequest, options?: AxiosRequestConfig): AxiosPromise<Get2SpacesIdTweetsResponse> {
            return localVarFp.getTweets(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns Tweet objects that appears in the provided User ID\'s home timeline
         * @summary User home timeline by User ID
         * @param {TweetsApiGetUserHomeTimelineRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserHomeTimeline(requestParameters: TweetsApiGetUserHomeTimelineRequest, options?: AxiosRequestConfig): AxiosPromise<Get2UsersIdTimelinesReverseChronologicalResponse> {
            return localVarFp.getUserHomeTimeline(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Hides or unhides a reply to an owned conversation.
         * @summary Hide replies
         * @param {TweetsApiHideReplyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hideReply(requestParameters: TweetsApiHideReplyRequest, options?: AxiosRequestConfig): AxiosPromise<TweetHideResponse> {
            return localVarFp.hideReply(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Causes the User (in the path) to like the specified Tweet. The User in the path must match the User context authorizing the request.
         * @summary Causes the User (in the path) to like the specified Tweet
         * @param {TweetsApiLikeTweetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        likeTweet(requestParameters: TweetsApiLikeTweetRequest, options?: AxiosRequestConfig): AxiosPromise<UsersLikesCreateResponse> {
            return localVarFp.likeTweet(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of Tweets associated with the provided List ID.
         * @summary List Tweets timeline by List ID.
         * @param {TweetsApiListByListIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listByListId(requestParameters: TweetsApiListByListIdRequest, options?: AxiosRequestConfig): AxiosPromise<Get2ListsIdTweetsResponse> {
            return localVarFp.listByListId(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of Tweets authored by the provided User ID
         * @summary User Tweets timeline by User ID
         * @param {TweetsApiListByUserIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listByUserId(requestParameters: TweetsApiListByUserIdRequest, options?: AxiosRequestConfig): AxiosPromise<Get2UsersIdTweetsResponse> {
            return localVarFp.listByUserId(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a variety of information about the Tweet specified by the requested ID.
         * @summary Tweet lookup by Tweet ID
         * @param {TweetsApiLookupByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupById(requestParameters: TweetsApiLookupByIdRequest, options?: AxiosRequestConfig): AxiosPromise<Get2TweetsIdResponse> {
            return localVarFp.lookupById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a variety of information about the Tweet specified by the requested ID.
         * @summary Tweet lookup by Tweet IDs
         * @param {TweetsApiLookupByTweetIdsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupByTweetIds(requestParameters: TweetsApiLookupByTweetIdsRequest, options?: AxiosRequestConfig): AxiosPromise<Get2TweetsResponse> {
            return localVarFp.lookupByTweetIds(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Causes the User (in the path) to retweet the specified Tweet. The User in the path must match the User context authorizing the request.
         * @summary Causes the User (in the path) to retweet the specified Tweet.
         * @param {TweetsApiRetweetTweetByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retweetTweetById(requestParameters: TweetsApiRetweetTweetByIdRequest, options?: AxiosRequestConfig): AxiosPromise<UsersRetweetsCreateResponse> {
            return localVarFp.retweetTweetById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns Tweets that match a search query.
         * @summary Full-archive search
         * @param {TweetsApiSearchAllRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAll(requestParameters: TweetsApiSearchAllRequest, options?: AxiosRequestConfig): AxiosPromise<Get2TweetsSearchAllResponse> {
            return localVarFp.searchAll(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns rules from a User\'s active rule set. Users can fetch all of their rules or a subset, specified by the provided rule ids.
         * @summary Rules lookup
         * @param {TweetsApiSearchStreamRulesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchStreamRules(requestParameters: TweetsApiSearchStreamRulesRequest, options?: AxiosRequestConfig): AxiosPromise<RulesLookupResponse> {
            return localVarFp.searchStreamRules(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Streams a deterministic 1% of public Tweets.
         * @summary Sample stream
         * @param {TweetsApiStreamSampleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamSample(requestParameters: TweetsApiStreamSampleRequest = {}, options?: AxiosRequestConfig): AxiosPromise<StreamingTweetResponse> {
            return localVarFp.streamSample(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Streams a deterministic 10% of public Tweets.
         * @summary Sample 10% stream
         * @param {TweetsApiStreamSample10Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamSample10(requestParameters: TweetsApiStreamSample10Request, options?: AxiosRequestConfig): AxiosPromise<Get2TweetsSample10StreamResponse> {
            return localVarFp.streamSample10(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Causes the User (in the path) to unlike the specified Tweet. The User must match the User context authorizing the request
         * @summary Causes the User (in the path) to unlike the specified Tweet
         * @param {TweetsApiUnlikeTweetByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlikeTweetById(requestParameters: TweetsApiUnlikeTweetByIdRequest, options?: AxiosRequestConfig): AxiosPromise<UsersLikesDeleteResponse> {
            return localVarFp.unlikeTweetById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Causes the User (in the path) to unretweet the specified Tweet. The User must match the User context authorizing the request
         * @summary Causes the User (in the path) to unretweet the specified Tweet
         * @param {TweetsApiUnretweetByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unretweetById(requestParameters: TweetsApiUnretweetByIdRequest, options?: AxiosRequestConfig): AxiosPromise<UsersRetweetsDeleteResponse> {
            return localVarFp.unretweetById(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addOrDeleteRules operation in TweetsApi.
 * @export
 * @interface TweetsApiAddOrDeleteRulesRequest
 */
export type TweetsApiAddOrDeleteRulesRequest = {
    
    /**
    * Dry Run can be used with both the add and delete action, with the expected result given, but without actually taking any action in the system (meaning the end state will always be as it was when the request was submitted). This is particularly useful to validate rule changes.
    * @type {boolean}
    * @memberof TweetsApiAddOrDeleteRules
    */
    readonly dryRun?: boolean
    
} & AddOrDeleteRulesRequest

/**
 * Request parameters for createTweet operation in TweetsApi.
 * @export
 * @interface TweetsApiCreateTweetRequest
 */
export type TweetsApiCreateTweetRequest = {
    
} & TweetCreateRequest

/**
 * Request parameters for deleteById operation in TweetsApi.
 * @export
 * @interface TweetsApiDeleteByIdRequest
 */
export type TweetsApiDeleteByIdRequest = {
    
    /**
    * The ID of the Tweet to be deleted.
    * @type {string}
    * @memberof TweetsApiDeleteById
    */
    readonly id: string
    
}

/**
 * Request parameters for getBuyersList operation in TweetsApi.
 * @export
 * @interface TweetsApiGetBuyersListRequest
 */
export type TweetsApiGetBuyersListRequest = {
    
    /**
    * The ID of the Space to be retrieved.
    * @type {string}
    * @memberof TweetsApiGetBuyersList
    */
    readonly id: string
    
    /**
    * This parameter is used to get a specified \'page\' of results.
    * @type {string}
    * @memberof TweetsApiGetBuyersList
    */
    readonly paginationToken?: string
    
    /**
    * The maximum number of results.
    * @type {number}
    * @memberof TweetsApiGetBuyersList
    */
    readonly maxResults?: number
    
    /**
    * A comma separated list of User fields to display.
    * @type {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>}
    * @memberof TweetsApiGetBuyersList
    */
    readonly userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>
    
    /**
    * A comma separated list of fields to expand.
    * @type {Set<'pinned_tweet_id'>}
    * @memberof TweetsApiGetBuyersList
    */
    readonly expansions?: Set<'pinned_tweet_id'>
    
    /**
    * A comma separated list of Tweet fields to display.
    * @type {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>}
    * @memberof TweetsApiGetBuyersList
    */
    readonly tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>
    
}

/**
 * Request parameters for getFilteredStream operation in TweetsApi.
 * @export
 * @interface TweetsApiGetFilteredStreamRequest
 */
export type TweetsApiGetFilteredStreamRequest = {
    
    /**
    * The number of minutes of backfill requested.
    * @type {number}
    * @memberof TweetsApiGetFilteredStream
    */
    readonly backfillMinutes?: number
    
    /**
    * YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided.
    * @type {string}
    * @memberof TweetsApiGetFilteredStream
    */
    readonly startTime?: string
    
    /**
    * YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.
    * @type {string}
    * @memberof TweetsApiGetFilteredStream
    */
    readonly endTime?: string
    
    /**
    * A comma separated list of Tweet fields to display.
    * @type {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>}
    * @memberof TweetsApiGetFilteredStream
    */
    readonly tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>
    
    /**
    * A comma separated list of fields to expand.
    * @type {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>}
    * @memberof TweetsApiGetFilteredStream
    */
    readonly expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>
    
    /**
    * A comma separated list of Media fields to display.
    * @type {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>}
    * @memberof TweetsApiGetFilteredStream
    */
    readonly mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>
    
    /**
    * A comma separated list of Poll fields to display.
    * @type {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>}
    * @memberof TweetsApiGetFilteredStream
    */
    readonly pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>
    
    /**
    * A comma separated list of User fields to display.
    * @type {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>}
    * @memberof TweetsApiGetFilteredStream
    */
    readonly userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>
    
    /**
    * A comma separated list of Place fields to display.
    * @type {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>}
    * @memberof TweetsApiGetFilteredStream
    */
    readonly placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>
    
}

/**
 * Request parameters for getFirehoseStream operation in TweetsApi.
 * @export
 * @interface TweetsApiGetFirehoseStreamRequest
 */
export type TweetsApiGetFirehoseStreamRequest = {
    
    /**
    * The partition number.
    * @type {number}
    * @memberof TweetsApiGetFirehoseStream
    */
    readonly partition: number
    
    /**
    * The number of minutes of backfill requested.
    * @type {number}
    * @memberof TweetsApiGetFirehoseStream
    */
    readonly backfillMinutes?: number
    
    /**
    * YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Tweets will be provided.
    * @type {string}
    * @memberof TweetsApiGetFirehoseStream
    */
    readonly startTime?: string
    
    /**
    * YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.
    * @type {string}
    * @memberof TweetsApiGetFirehoseStream
    */
    readonly endTime?: string
    
    /**
    * A comma separated list of Tweet fields to display.
    * @type {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>}
    * @memberof TweetsApiGetFirehoseStream
    */
    readonly tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>
    
    /**
    * A comma separated list of fields to expand.
    * @type {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>}
    * @memberof TweetsApiGetFirehoseStream
    */
    readonly expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>
    
    /**
    * A comma separated list of Media fields to display.
    * @type {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>}
    * @memberof TweetsApiGetFirehoseStream
    */
    readonly mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>
    
    /**
    * A comma separated list of Poll fields to display.
    * @type {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>}
    * @memberof TweetsApiGetFirehoseStream
    */
    readonly pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>
    
    /**
    * A comma separated list of User fields to display.
    * @type {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>}
    * @memberof TweetsApiGetFirehoseStream
    */
    readonly userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>
    
    /**
    * A comma separated list of Place fields to display.
    * @type {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>}
    * @memberof TweetsApiGetFirehoseStream
    */
    readonly placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>
    
}

/**
 * Request parameters for getLikedTweets operation in TweetsApi.
 * @export
 * @interface TweetsApiGetLikedTweetsRequest
 */
export type TweetsApiGetLikedTweetsRequest = {
    
    /**
    * The ID of the User to lookup.
    * @type {string}
    * @memberof TweetsApiGetLikedTweets
    */
    readonly id: string
    
    /**
    * The maximum number of results.
    * @type {number}
    * @memberof TweetsApiGetLikedTweets
    */
    readonly maxResults?: number
    
    /**
    * This parameter is used to get the next \'page\' of results.
    * @type {string}
    * @memberof TweetsApiGetLikedTweets
    */
    readonly paginationToken?: string
    
    /**
    * A comma separated list of Tweet fields to display.
    * @type {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>}
    * @memberof TweetsApiGetLikedTweets
    */
    readonly tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>
    
    /**
    * A comma separated list of fields to expand.
    * @type {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>}
    * @memberof TweetsApiGetLikedTweets
    */
    readonly expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>
    
    /**
    * A comma separated list of Media fields to display.
    * @type {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>}
    * @memberof TweetsApiGetLikedTweets
    */
    readonly mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>
    
    /**
    * A comma separated list of Poll fields to display.
    * @type {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>}
    * @memberof TweetsApiGetLikedTweets
    */
    readonly pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>
    
    /**
    * A comma separated list of User fields to display.
    * @type {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>}
    * @memberof TweetsApiGetLikedTweets
    */
    readonly userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>
    
    /**
    * A comma separated list of Place fields to display.
    * @type {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>}
    * @memberof TweetsApiGetLikedTweets
    */
    readonly placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>
    
}

/**
 * Request parameters for getMentionsById operation in TweetsApi.
 * @export
 * @interface TweetsApiGetMentionsByIdRequest
 */
export type TweetsApiGetMentionsByIdRequest = {
    
    /**
    * The ID of the User to lookup.
    * @type {string}
    * @memberof TweetsApiGetMentionsById
    */
    readonly id: string
    
    /**
    * The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
    * @type {string}
    * @memberof TweetsApiGetMentionsById
    */
    readonly sinceId?: string
    
    /**
    * The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
    * @type {string}
    * @memberof TweetsApiGetMentionsById
    */
    readonly untilId?: string
    
    /**
    * The maximum number of results.
    * @type {number}
    * @memberof TweetsApiGetMentionsById
    */
    readonly maxResults?: number
    
    /**
    * This parameter is used to get the next \'page\' of results.
    * @type {string}
    * @memberof TweetsApiGetMentionsById
    */
    readonly paginationToken?: string
    
    /**
    * YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
    * @type {string}
    * @memberof TweetsApiGetMentionsById
    */
    readonly startTime?: string
    
    /**
    * YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
    * @type {string}
    * @memberof TweetsApiGetMentionsById
    */
    readonly endTime?: string
    
    /**
    * A comma separated list of Tweet fields to display.
    * @type {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>}
    * @memberof TweetsApiGetMentionsById
    */
    readonly tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>
    
    /**
    * A comma separated list of fields to expand.
    * @type {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>}
    * @memberof TweetsApiGetMentionsById
    */
    readonly expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>
    
    /**
    * A comma separated list of Media fields to display.
    * @type {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>}
    * @memberof TweetsApiGetMentionsById
    */
    readonly mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>
    
    /**
    * A comma separated list of Poll fields to display.
    * @type {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>}
    * @memberof TweetsApiGetMentionsById
    */
    readonly pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>
    
    /**
    * A comma separated list of User fields to display.
    * @type {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>}
    * @memberof TweetsApiGetMentionsById
    */
    readonly userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>
    
    /**
    * A comma separated list of Place fields to display.
    * @type {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>}
    * @memberof TweetsApiGetMentionsById
    */
    readonly placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>
    
}

/**
 * Request parameters for getQuoteTweets operation in TweetsApi.
 * @export
 * @interface TweetsApiGetQuoteTweetsRequest
 */
export type TweetsApiGetQuoteTweetsRequest = {
    
    /**
    * A single Tweet ID.
    * @type {string}
    * @memberof TweetsApiGetQuoteTweets
    */
    readonly id: string
    
    /**
    * The maximum number of results to be returned.
    * @type {number}
    * @memberof TweetsApiGetQuoteTweets
    */
    readonly maxResults?: number
    
    /**
    * This parameter is used to get a specified \'page\' of results.
    * @type {string}
    * @memberof TweetsApiGetQuoteTweets
    */
    readonly paginationToken?: string
    
    /**
    * The set of entities to exclude (e.g. \'replies\' or \'retweets\').
    * @type {Set<'replies' | 'retweets'>}
    * @memberof TweetsApiGetQuoteTweets
    */
    readonly exclude?: Set<'replies' | 'retweets'>
    
    /**
    * A comma separated list of Tweet fields to display.
    * @type {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>}
    * @memberof TweetsApiGetQuoteTweets
    */
    readonly tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>
    
    /**
    * A comma separated list of fields to expand.
    * @type {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>}
    * @memberof TweetsApiGetQuoteTweets
    */
    readonly expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>
    
    /**
    * A comma separated list of Media fields to display.
    * @type {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>}
    * @memberof TweetsApiGetQuoteTweets
    */
    readonly mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>
    
    /**
    * A comma separated list of Poll fields to display.
    * @type {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>}
    * @memberof TweetsApiGetQuoteTweets
    */
    readonly pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>
    
    /**
    * A comma separated list of User fields to display.
    * @type {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>}
    * @memberof TweetsApiGetQuoteTweets
    */
    readonly userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>
    
    /**
    * A comma separated list of Place fields to display.
    * @type {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>}
    * @memberof TweetsApiGetQuoteTweets
    */
    readonly placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>
    
}

/**
 * Request parameters for getRecentTweetCounts operation in TweetsApi.
 * @export
 * @interface TweetsApiGetRecentTweetCountsRequest
 */
export type TweetsApiGetRecentTweetCountsRequest = {
    
    /**
    * One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.
    * @type {string}
    * @memberof TweetsApiGetRecentTweetCounts
    */
    readonly query: string
    
    /**
    * YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
    * @type {string}
    * @memberof TweetsApiGetRecentTweetCounts
    */
    readonly startTime?: string
    
    /**
    * YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
    * @type {string}
    * @memberof TweetsApiGetRecentTweetCounts
    */
    readonly endTime?: string
    
    /**
    * Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
    * @type {string}
    * @memberof TweetsApiGetRecentTweetCounts
    */
    readonly sinceId?: string
    
    /**
    * Returns results with a Tweet ID less than (that is, older than) the specified ID.
    * @type {string}
    * @memberof TweetsApiGetRecentTweetCounts
    */
    readonly untilId?: string
    
    /**
    * This parameter is used to get the next \'page\' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
    * @type {string}
    * @memberof TweetsApiGetRecentTweetCounts
    */
    readonly nextToken?: string
    
    /**
    * This parameter is used to get the next \'page\' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
    * @type {string}
    * @memberof TweetsApiGetRecentTweetCounts
    */
    readonly paginationToken?: string
    
    /**
    * The granularity for the search counts results.
    * @type {'minute' | 'hour' | 'day'}
    * @memberof TweetsApiGetRecentTweetCounts
    */
    readonly granularity?: 'minute' | 'hour' | 'day'
    
    /**
    * A comma separated list of SearchCount fields to display.
    * @type {Set<'end' | 'start' | 'tweet_count'>}
    * @memberof TweetsApiGetRecentTweetCounts
    */
    readonly searchCountFields?: Set<'end' | 'start' | 'tweet_count'>
    
}

/**
 * Request parameters for getRecentTweets operation in TweetsApi.
 * @export
 * @interface TweetsApiGetRecentTweetsRequest
 */
export type TweetsApiGetRecentTweetsRequest = {
    
    /**
    * One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.
    * @type {string}
    * @memberof TweetsApiGetRecentTweets
    */
    readonly query: string
    
    /**
    * YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
    * @type {string}
    * @memberof TweetsApiGetRecentTweets
    */
    readonly startTime?: string
    
    /**
    * YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
    * @type {string}
    * @memberof TweetsApiGetRecentTweets
    */
    readonly endTime?: string
    
    /**
    * Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
    * @type {string}
    * @memberof TweetsApiGetRecentTweets
    */
    readonly sinceId?: string
    
    /**
    * Returns results with a Tweet ID less than (that is, older than) the specified ID.
    * @type {string}
    * @memberof TweetsApiGetRecentTweets
    */
    readonly untilId?: string
    
    /**
    * The maximum number of search results to be returned by a request.
    * @type {number}
    * @memberof TweetsApiGetRecentTweets
    */
    readonly maxResults?: number
    
    /**
    * This parameter is used to get the next \'page\' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
    * @type {string}
    * @memberof TweetsApiGetRecentTweets
    */
    readonly nextToken?: string
    
    /**
    * This parameter is used to get the next \'page\' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
    * @type {string}
    * @memberof TweetsApiGetRecentTweets
    */
    readonly paginationToken?: string
    
    /**
    * This order in which to return results.
    * @type {'recency' | 'relevancy'}
    * @memberof TweetsApiGetRecentTweets
    */
    readonly sortOrder?: 'recency' | 'relevancy'
    
    /**
    * A comma separated list of Tweet fields to display.
    * @type {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>}
    * @memberof TweetsApiGetRecentTweets
    */
    readonly tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>
    
    /**
    * A comma separated list of fields to expand.
    * @type {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>}
    * @memberof TweetsApiGetRecentTweets
    */
    readonly expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>
    
    /**
    * A comma separated list of Media fields to display.
    * @type {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>}
    * @memberof TweetsApiGetRecentTweets
    */
    readonly mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>
    
    /**
    * A comma separated list of Poll fields to display.
    * @type {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>}
    * @memberof TweetsApiGetRecentTweets
    */
    readonly pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>
    
    /**
    * A comma separated list of User fields to display.
    * @type {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>}
    * @memberof TweetsApiGetRecentTweets
    */
    readonly userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>
    
    /**
    * A comma separated list of Place fields to display.
    * @type {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>}
    * @memberof TweetsApiGetRecentTweets
    */
    readonly placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>
    
}

/**
 * Request parameters for getTweetCounts operation in TweetsApi.
 * @export
 * @interface TweetsApiGetTweetCountsRequest
 */
export type TweetsApiGetTweetCountsRequest = {
    
    /**
    * One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.
    * @type {string}
    * @memberof TweetsApiGetTweetCounts
    */
    readonly query: string
    
    /**
    * YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
    * @type {string}
    * @memberof TweetsApiGetTweetCounts
    */
    readonly startTime?: string
    
    /**
    * YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
    * @type {string}
    * @memberof TweetsApiGetTweetCounts
    */
    readonly endTime?: string
    
    /**
    * Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
    * @type {string}
    * @memberof TweetsApiGetTweetCounts
    */
    readonly sinceId?: string
    
    /**
    * Returns results with a Tweet ID less than (that is, older than) the specified ID.
    * @type {string}
    * @memberof TweetsApiGetTweetCounts
    */
    readonly untilId?: string
    
    /**
    * This parameter is used to get the next \'page\' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
    * @type {string}
    * @memberof TweetsApiGetTweetCounts
    */
    readonly nextToken?: string
    
    /**
    * This parameter is used to get the next \'page\' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
    * @type {string}
    * @memberof TweetsApiGetTweetCounts
    */
    readonly paginationToken?: string
    
    /**
    * The granularity for the search counts results.
    * @type {'minute' | 'hour' | 'day'}
    * @memberof TweetsApiGetTweetCounts
    */
    readonly granularity?: 'minute' | 'hour' | 'day'
    
    /**
    * A comma separated list of SearchCount fields to display.
    * @type {Set<'end' | 'start' | 'tweet_count'>}
    * @memberof TweetsApiGetTweetCounts
    */
    readonly searchCountFields?: Set<'end' | 'start' | 'tweet_count'>
    
}

/**
 * Request parameters for getTweets operation in TweetsApi.
 * @export
 * @interface TweetsApiGetTweetsRequest
 */
export type TweetsApiGetTweetsRequest = {
    
    /**
    * The ID of the Space to be retrieved.
    * @type {string}
    * @memberof TweetsApiGetTweets
    */
    readonly id: string
    
    /**
    * The number of Tweets to fetch from the provided space. If not provided, the value will default to the maximum of 100.
    * @type {number}
    * @memberof TweetsApiGetTweets
    */
    readonly maxResults?: number
    
    /**
    * A comma separated list of Tweet fields to display.
    * @type {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>}
    * @memberof TweetsApiGetTweets
    */
    readonly tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>
    
    /**
    * A comma separated list of fields to expand.
    * @type {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>}
    * @memberof TweetsApiGetTweets
    */
    readonly expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>
    
    /**
    * A comma separated list of Media fields to display.
    * @type {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>}
    * @memberof TweetsApiGetTweets
    */
    readonly mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>
    
    /**
    * A comma separated list of Poll fields to display.
    * @type {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>}
    * @memberof TweetsApiGetTweets
    */
    readonly pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>
    
    /**
    * A comma separated list of User fields to display.
    * @type {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>}
    * @memberof TweetsApiGetTweets
    */
    readonly userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>
    
    /**
    * A comma separated list of Place fields to display.
    * @type {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>}
    * @memberof TweetsApiGetTweets
    */
    readonly placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>
    
}

/**
 * Request parameters for getUserHomeTimeline operation in TweetsApi.
 * @export
 * @interface TweetsApiGetUserHomeTimelineRequest
 */
export type TweetsApiGetUserHomeTimelineRequest = {
    
    /**
    * The ID of the authenticated source User to list Reverse Chronological Timeline Tweets of.
    * @type {string}
    * @memberof TweetsApiGetUserHomeTimeline
    */
    readonly id: string
    
    /**
    * The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
    * @type {string}
    * @memberof TweetsApiGetUserHomeTimeline
    */
    readonly sinceId?: string
    
    /**
    * The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
    * @type {string}
    * @memberof TweetsApiGetUserHomeTimeline
    */
    readonly untilId?: string
    
    /**
    * The maximum number of results.
    * @type {number}
    * @memberof TweetsApiGetUserHomeTimeline
    */
    readonly maxResults?: number
    
    /**
    * This parameter is used to get the next \'page\' of results.
    * @type {string}
    * @memberof TweetsApiGetUserHomeTimeline
    */
    readonly paginationToken?: string
    
    /**
    * The set of entities to exclude (e.g. \'replies\' or \'retweets\').
    * @type {Set<'replies' | 'retweets'>}
    * @memberof TweetsApiGetUserHomeTimeline
    */
    readonly exclude?: Set<'replies' | 'retweets'>
    
    /**
    * YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
    * @type {string}
    * @memberof TweetsApiGetUserHomeTimeline
    */
    readonly startTime?: string
    
    /**
    * YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
    * @type {string}
    * @memberof TweetsApiGetUserHomeTimeline
    */
    readonly endTime?: string
    
    /**
    * A comma separated list of Tweet fields to display.
    * @type {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>}
    * @memberof TweetsApiGetUserHomeTimeline
    */
    readonly tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>
    
    /**
    * A comma separated list of fields to expand.
    * @type {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>}
    * @memberof TweetsApiGetUserHomeTimeline
    */
    readonly expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>
    
    /**
    * A comma separated list of Media fields to display.
    * @type {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>}
    * @memberof TweetsApiGetUserHomeTimeline
    */
    readonly mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>
    
    /**
    * A comma separated list of Poll fields to display.
    * @type {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>}
    * @memberof TweetsApiGetUserHomeTimeline
    */
    readonly pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>
    
    /**
    * A comma separated list of User fields to display.
    * @type {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>}
    * @memberof TweetsApiGetUserHomeTimeline
    */
    readonly userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>
    
    /**
    * A comma separated list of Place fields to display.
    * @type {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>}
    * @memberof TweetsApiGetUserHomeTimeline
    */
    readonly placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>
    
}

/**
 * Request parameters for hideReply operation in TweetsApi.
 * @export
 * @interface TweetsApiHideReplyRequest
 */
export type TweetsApiHideReplyRequest = {
    
    /**
    * The ID of the reply that you want to hide or unhide.
    * @type {string}
    * @memberof TweetsApiHideReply
    */
    readonly tweetId: string
    
} & TweetHideRequest

/**
 * Request parameters for likeTweet operation in TweetsApi.
 * @export
 * @interface TweetsApiLikeTweetRequest
 */
export type TweetsApiLikeTweetRequest = {
    
    /**
    * The ID of the authenticated source User that is requesting to like the Tweet.
    * @type {string}
    * @memberof TweetsApiLikeTweet
    */
    readonly id: string
    
} & UsersLikesCreateRequest

/**
 * Request parameters for listByListId operation in TweetsApi.
 * @export
 * @interface TweetsApiListByListIdRequest
 */
export type TweetsApiListByListIdRequest = {
    
    /**
    * The ID of the List.
    * @type {string}
    * @memberof TweetsApiListByListId
    */
    readonly id: string
    
    /**
    * The maximum number of results.
    * @type {number}
    * @memberof TweetsApiListByListId
    */
    readonly maxResults?: number
    
    /**
    * This parameter is used to get the next \'page\' of results.
    * @type {string}
    * @memberof TweetsApiListByListId
    */
    readonly paginationToken?: string
    
    /**
    * A comma separated list of Tweet fields to display.
    * @type {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>}
    * @memberof TweetsApiListByListId
    */
    readonly tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>
    
    /**
    * A comma separated list of fields to expand.
    * @type {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>}
    * @memberof TweetsApiListByListId
    */
    readonly expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>
    
    /**
    * A comma separated list of Media fields to display.
    * @type {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>}
    * @memberof TweetsApiListByListId
    */
    readonly mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>
    
    /**
    * A comma separated list of Poll fields to display.
    * @type {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>}
    * @memberof TweetsApiListByListId
    */
    readonly pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>
    
    /**
    * A comma separated list of User fields to display.
    * @type {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>}
    * @memberof TweetsApiListByListId
    */
    readonly userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>
    
    /**
    * A comma separated list of Place fields to display.
    * @type {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>}
    * @memberof TweetsApiListByListId
    */
    readonly placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>
    
}

/**
 * Request parameters for listByUserId operation in TweetsApi.
 * @export
 * @interface TweetsApiListByUserIdRequest
 */
export type TweetsApiListByUserIdRequest = {
    
    /**
    * The ID of the User to lookup.
    * @type {string}
    * @memberof TweetsApiListByUserId
    */
    readonly id: string
    
    /**
    * The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
    * @type {string}
    * @memberof TweetsApiListByUserId
    */
    readonly sinceId?: string
    
    /**
    * The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
    * @type {string}
    * @memberof TweetsApiListByUserId
    */
    readonly untilId?: string
    
    /**
    * The maximum number of results.
    * @type {number}
    * @memberof TweetsApiListByUserId
    */
    readonly maxResults?: number
    
    /**
    * This parameter is used to get the next \'page\' of results.
    * @type {string}
    * @memberof TweetsApiListByUserId
    */
    readonly paginationToken?: string
    
    /**
    * The set of entities to exclude (e.g. \'replies\' or \'retweets\').
    * @type {Set<'replies' | 'retweets'>}
    * @memberof TweetsApiListByUserId
    */
    readonly exclude?: Set<'replies' | 'retweets'>
    
    /**
    * YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
    * @type {string}
    * @memberof TweetsApiListByUserId
    */
    readonly startTime?: string
    
    /**
    * YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
    * @type {string}
    * @memberof TweetsApiListByUserId
    */
    readonly endTime?: string
    
    /**
    * A comma separated list of Tweet fields to display.
    * @type {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>}
    * @memberof TweetsApiListByUserId
    */
    readonly tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>
    
    /**
    * A comma separated list of fields to expand.
    * @type {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>}
    * @memberof TweetsApiListByUserId
    */
    readonly expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>
    
    /**
    * A comma separated list of Media fields to display.
    * @type {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>}
    * @memberof TweetsApiListByUserId
    */
    readonly mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>
    
    /**
    * A comma separated list of Poll fields to display.
    * @type {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>}
    * @memberof TweetsApiListByUserId
    */
    readonly pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>
    
    /**
    * A comma separated list of User fields to display.
    * @type {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>}
    * @memberof TweetsApiListByUserId
    */
    readonly userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>
    
    /**
    * A comma separated list of Place fields to display.
    * @type {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>}
    * @memberof TweetsApiListByUserId
    */
    readonly placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>
    
}

/**
 * Request parameters for lookupById operation in TweetsApi.
 * @export
 * @interface TweetsApiLookupByIdRequest
 */
export type TweetsApiLookupByIdRequest = {
    
    /**
    * A single Tweet ID.
    * @type {string}
    * @memberof TweetsApiLookupById
    */
    readonly id: string
    
    /**
    * A comma separated list of Tweet fields to display.
    * @type {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>}
    * @memberof TweetsApiLookupById
    */
    readonly tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>
    
    /**
    * A comma separated list of fields to expand.
    * @type {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>}
    * @memberof TweetsApiLookupById
    */
    readonly expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>
    
    /**
    * A comma separated list of Media fields to display.
    * @type {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>}
    * @memberof TweetsApiLookupById
    */
    readonly mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>
    
    /**
    * A comma separated list of Poll fields to display.
    * @type {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>}
    * @memberof TweetsApiLookupById
    */
    readonly pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>
    
    /**
    * A comma separated list of User fields to display.
    * @type {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>}
    * @memberof TweetsApiLookupById
    */
    readonly userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>
    
    /**
    * A comma separated list of Place fields to display.
    * @type {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>}
    * @memberof TweetsApiLookupById
    */
    readonly placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>
    
}

/**
 * Request parameters for lookupByTweetIds operation in TweetsApi.
 * @export
 * @interface TweetsApiLookupByTweetIdsRequest
 */
export type TweetsApiLookupByTweetIdsRequest = {
    
    /**
    * A comma separated list of Tweet IDs. Up to 100 are allowed in a single request.
    * @type {Array<string>}
    * @memberof TweetsApiLookupByTweetIds
    */
    readonly ids: Array<string>
    
    /**
    * A comma separated list of Tweet fields to display.
    * @type {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>}
    * @memberof TweetsApiLookupByTweetIds
    */
    readonly tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>
    
    /**
    * A comma separated list of fields to expand.
    * @type {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>}
    * @memberof TweetsApiLookupByTweetIds
    */
    readonly expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>
    
    /**
    * A comma separated list of Media fields to display.
    * @type {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>}
    * @memberof TweetsApiLookupByTweetIds
    */
    readonly mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>
    
    /**
    * A comma separated list of Poll fields to display.
    * @type {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>}
    * @memberof TweetsApiLookupByTweetIds
    */
    readonly pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>
    
    /**
    * A comma separated list of User fields to display.
    * @type {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>}
    * @memberof TweetsApiLookupByTweetIds
    */
    readonly userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>
    
    /**
    * A comma separated list of Place fields to display.
    * @type {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>}
    * @memberof TweetsApiLookupByTweetIds
    */
    readonly placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>
    
}

/**
 * Request parameters for retweetTweetById operation in TweetsApi.
 * @export
 * @interface TweetsApiRetweetTweetByIdRequest
 */
export type TweetsApiRetweetTweetByIdRequest = {
    
    /**
    * The ID of the authenticated source User that is requesting to retweet the Tweet.
    * @type {string}
    * @memberof TweetsApiRetweetTweetById
    */
    readonly id: string
    
} & UsersRetweetsCreateRequest

/**
 * Request parameters for searchAll operation in TweetsApi.
 * @export
 * @interface TweetsApiSearchAllRequest
 */
export type TweetsApiSearchAllRequest = {
    
    /**
    * One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.
    * @type {string}
    * @memberof TweetsApiSearchAll
    */
    readonly query: string
    
    /**
    * YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
    * @type {string}
    * @memberof TweetsApiSearchAll
    */
    readonly startTime?: string
    
    /**
    * YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
    * @type {string}
    * @memberof TweetsApiSearchAll
    */
    readonly endTime?: string
    
    /**
    * Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
    * @type {string}
    * @memberof TweetsApiSearchAll
    */
    readonly sinceId?: string
    
    /**
    * Returns results with a Tweet ID less than (that is, older than) the specified ID.
    * @type {string}
    * @memberof TweetsApiSearchAll
    */
    readonly untilId?: string
    
    /**
    * The maximum number of search results to be returned by a request.
    * @type {number}
    * @memberof TweetsApiSearchAll
    */
    readonly maxResults?: number
    
    /**
    * This parameter is used to get the next \'page\' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
    * @type {string}
    * @memberof TweetsApiSearchAll
    */
    readonly nextToken?: string
    
    /**
    * This parameter is used to get the next \'page\' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
    * @type {string}
    * @memberof TweetsApiSearchAll
    */
    readonly paginationToken?: string
    
    /**
    * This order in which to return results.
    * @type {'recency' | 'relevancy'}
    * @memberof TweetsApiSearchAll
    */
    readonly sortOrder?: 'recency' | 'relevancy'
    
    /**
    * A comma separated list of Tweet fields to display.
    * @type {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>}
    * @memberof TweetsApiSearchAll
    */
    readonly tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>
    
    /**
    * A comma separated list of fields to expand.
    * @type {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>}
    * @memberof TweetsApiSearchAll
    */
    readonly expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>
    
    /**
    * A comma separated list of Media fields to display.
    * @type {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>}
    * @memberof TweetsApiSearchAll
    */
    readonly mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>
    
    /**
    * A comma separated list of Poll fields to display.
    * @type {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>}
    * @memberof TweetsApiSearchAll
    */
    readonly pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>
    
    /**
    * A comma separated list of User fields to display.
    * @type {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>}
    * @memberof TweetsApiSearchAll
    */
    readonly userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>
    
    /**
    * A comma separated list of Place fields to display.
    * @type {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>}
    * @memberof TweetsApiSearchAll
    */
    readonly placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>
    
}

/**
 * Request parameters for searchStreamRules operation in TweetsApi.
 * @export
 * @interface TweetsApiSearchStreamRulesRequest
 */
export type TweetsApiSearchStreamRulesRequest = {
    
    /**
    * A comma-separated list of Rule IDs.
    * @type {Array<string>}
    * @memberof TweetsApiSearchStreamRules
    */
    readonly ids?: Array<string>
    
    /**
    * The maximum number of results.
    * @type {number}
    * @memberof TweetsApiSearchStreamRules
    */
    readonly maxResults?: number
    
    /**
    * This value is populated by passing the \'next_token\' returned in a request to paginate through results.
    * @type {string}
    * @memberof TweetsApiSearchStreamRules
    */
    readonly paginationToken?: string
    
}

/**
 * Request parameters for streamSample operation in TweetsApi.
 * @export
 * @interface TweetsApiStreamSampleRequest
 */
export type TweetsApiStreamSampleRequest = {
    
    /**
    * The number of minutes of backfill requested.
    * @type {number}
    * @memberof TweetsApiStreamSample
    */
    readonly backfillMinutes?: number
    
    /**
    * A comma separated list of Tweet fields to display.
    * @type {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>}
    * @memberof TweetsApiStreamSample
    */
    readonly tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>
    
    /**
    * A comma separated list of fields to expand.
    * @type {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>}
    * @memberof TweetsApiStreamSample
    */
    readonly expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>
    
    /**
    * A comma separated list of Media fields to display.
    * @type {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>}
    * @memberof TweetsApiStreamSample
    */
    readonly mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>
    
    /**
    * A comma separated list of Poll fields to display.
    * @type {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>}
    * @memberof TweetsApiStreamSample
    */
    readonly pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>
    
    /**
    * A comma separated list of User fields to display.
    * @type {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>}
    * @memberof TweetsApiStreamSample
    */
    readonly userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>
    
    /**
    * A comma separated list of Place fields to display.
    * @type {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>}
    * @memberof TweetsApiStreamSample
    */
    readonly placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>
    
}

/**
 * Request parameters for streamSample10 operation in TweetsApi.
 * @export
 * @interface TweetsApiStreamSample10Request
 */
export type TweetsApiStreamSample10Request = {
    
    /**
    * The partition number.
    * @type {number}
    * @memberof TweetsApiStreamSample10
    */
    readonly partition: number
    
    /**
    * The number of minutes of backfill requested.
    * @type {number}
    * @memberof TweetsApiStreamSample10
    */
    readonly backfillMinutes?: number
    
    /**
    * YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Tweets will be provided.
    * @type {string}
    * @memberof TweetsApiStreamSample10
    */
    readonly startTime?: string
    
    /**
    * YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.
    * @type {string}
    * @memberof TweetsApiStreamSample10
    */
    readonly endTime?: string
    
    /**
    * A comma separated list of Tweet fields to display.
    * @type {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>}
    * @memberof TweetsApiStreamSample10
    */
    readonly tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>
    
    /**
    * A comma separated list of fields to expand.
    * @type {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>}
    * @memberof TweetsApiStreamSample10
    */
    readonly expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>
    
    /**
    * A comma separated list of Media fields to display.
    * @type {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>}
    * @memberof TweetsApiStreamSample10
    */
    readonly mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>
    
    /**
    * A comma separated list of Poll fields to display.
    * @type {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>}
    * @memberof TweetsApiStreamSample10
    */
    readonly pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>
    
    /**
    * A comma separated list of User fields to display.
    * @type {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>}
    * @memberof TweetsApiStreamSample10
    */
    readonly userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>
    
    /**
    * A comma separated list of Place fields to display.
    * @type {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>}
    * @memberof TweetsApiStreamSample10
    */
    readonly placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>
    
}

/**
 * Request parameters for unlikeTweetById operation in TweetsApi.
 * @export
 * @interface TweetsApiUnlikeTweetByIdRequest
 */
export type TweetsApiUnlikeTweetByIdRequest = {
    
    /**
    * The ID of the authenticated source User that is requesting to unlike the Tweet.
    * @type {string}
    * @memberof TweetsApiUnlikeTweetById
    */
    readonly id: string
    
    /**
    * The ID of the Tweet that the User is requesting to unlike.
    * @type {string}
    * @memberof TweetsApiUnlikeTweetById
    */
    readonly tweetId: string
    
}

/**
 * Request parameters for unretweetById operation in TweetsApi.
 * @export
 * @interface TweetsApiUnretweetByIdRequest
 */
export type TweetsApiUnretweetByIdRequest = {
    
    /**
    * The ID of the authenticated source User that is requesting to retweet the Tweet.
    * @type {string}
    * @memberof TweetsApiUnretweetById
    */
    readonly id: string
    
    /**
    * The ID of the Tweet that the User is requesting to unretweet.
    * @type {string}
    * @memberof TweetsApiUnretweetById
    */
    readonly sourceTweetId: string
    
}

/**
 * TweetsApiGenerated - object-oriented interface
 * @export
 * @class TweetsApiGenerated
 * @extends {BaseAPI}
 */
export class TweetsApiGenerated extends BaseAPI {
    /**
     * Add or delete rules from a User\'s active rule set. Users can provide unique, optionally tagged rules to add. Users can delete their entire rule set or a subset specified by rule ids or values.
     * @summary Add/Delete rules
     * @param {TweetsApiAddOrDeleteRulesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApiGenerated
     */
    public addOrDeleteRules(requestParameters: TweetsApiAddOrDeleteRulesRequest, options?: AxiosRequestConfig) {
        return TweetsApiFp(this.configuration).addOrDeleteRules(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Causes the User to create a Tweet under the authorized account.
     * @summary Creation of a Tweet
     * @param {TweetsApiCreateTweetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApiGenerated
     */
    public createTweet(requestParameters: TweetsApiCreateTweetRequest, options?: AxiosRequestConfig) {
        return TweetsApiFp(this.configuration).createTweet(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete specified Tweet (in the path) by ID.
     * @summary Tweet delete by Tweet ID
     * @param {TweetsApiDeleteByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApiGenerated
     */
    public deleteById(requestParameters: TweetsApiDeleteByIdRequest, options?: AxiosRequestConfig) {
        return TweetsApiFp(this.configuration).deleteById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of Users who purchased a ticket to the given space
     * @summary Retrieve the list of Users who purchased a ticket to the given space
     * @param {TweetsApiGetBuyersListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApiGenerated
     */
    public getBuyersList(requestParameters: TweetsApiGetBuyersListRequest, options?: AxiosRequestConfig) {
        return TweetsApiFp(this.configuration).getBuyersList(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Streams Tweets matching the stream\'s active rule set.
     * @summary Filtered stream
     * @param {TweetsApiGetFilteredStreamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApiGenerated
     */
    public getFilteredStream(requestParameters: TweetsApiGetFilteredStreamRequest = {}, options?: AxiosRequestConfig) {
        return TweetsApiFp(this.configuration).getFilteredStream(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Streams 100% of public Tweets.
     * @summary Firehose stream
     * @param {TweetsApiGetFirehoseStreamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApiGenerated
     */
    public getFirehoseStream(requestParameters: TweetsApiGetFirehoseStreamRequest, options?: AxiosRequestConfig) {
        return TweetsApiFp(this.configuration).getFirehoseStream(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of Tweets liked by the provided User ID
     * @summary Returns Tweet objects liked by the provided User ID
     * @param {TweetsApiGetLikedTweetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApiGenerated
     */
    public getLikedTweets(requestParameters: TweetsApiGetLikedTweetsRequest, options?: AxiosRequestConfig) {
        return TweetsApiFp(this.configuration).getLikedTweets(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns Tweet objects that mention username associated to the provided User ID
     * @summary User mention timeline by User ID
     * @param {TweetsApiGetMentionsByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApiGenerated
     */
    public getMentionsById(requestParameters: TweetsApiGetMentionsByIdRequest, options?: AxiosRequestConfig) {
        return TweetsApiFp(this.configuration).getMentionsById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a variety of information about each Tweet that quotes the Tweet specified by the requested ID.
     * @summary Retrieve Tweets that quote a Tweet.
     * @param {TweetsApiGetQuoteTweetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApiGenerated
     */
    public getQuoteTweets(requestParameters: TweetsApiGetQuoteTweetsRequest, options?: AxiosRequestConfig) {
        return TweetsApiFp(this.configuration).getQuoteTweets(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns Tweet Counts from the last 7 days that match a search query.
     * @summary Recent search counts
     * @param {TweetsApiGetRecentTweetCountsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApiGenerated
     */
    public getRecentTweetCounts(requestParameters: TweetsApiGetRecentTweetCountsRequest, options?: AxiosRequestConfig) {
        return TweetsApiFp(this.configuration).getRecentTweetCounts(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns Tweets from the last 7 days that match a search query.
     * @summary Recent search
     * @param {TweetsApiGetRecentTweetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApiGenerated
     */
    public getRecentTweets(requestParameters: TweetsApiGetRecentTweetsRequest, options?: AxiosRequestConfig) {
        return TweetsApiFp(this.configuration).getRecentTweets(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns Tweet Counts that match a search query.
     * @summary Full archive search counts
     * @param {TweetsApiGetTweetCountsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApiGenerated
     */
    public getTweetCounts(requestParameters: TweetsApiGetTweetCountsRequest, options?: AxiosRequestConfig) {
        return TweetsApiFp(this.configuration).getTweetCounts(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves Tweets shared in the specified Space.
     * @summary Retrieve Tweets from a Space.
     * @param {TweetsApiGetTweetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApiGenerated
     */
    public getTweets(requestParameters: TweetsApiGetTweetsRequest, options?: AxiosRequestConfig) {
        return TweetsApiFp(this.configuration).getTweets(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns Tweet objects that appears in the provided User ID\'s home timeline
     * @summary User home timeline by User ID
     * @param {TweetsApiGetUserHomeTimelineRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApiGenerated
     */
    public getUserHomeTimeline(requestParameters: TweetsApiGetUserHomeTimelineRequest, options?: AxiosRequestConfig) {
        return TweetsApiFp(this.configuration).getUserHomeTimeline(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Hides or unhides a reply to an owned conversation.
     * @summary Hide replies
     * @param {TweetsApiHideReplyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApiGenerated
     */
    public hideReply(requestParameters: TweetsApiHideReplyRequest, options?: AxiosRequestConfig) {
        return TweetsApiFp(this.configuration).hideReply(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Causes the User (in the path) to like the specified Tweet. The User in the path must match the User context authorizing the request.
     * @summary Causes the User (in the path) to like the specified Tweet
     * @param {TweetsApiLikeTweetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApiGenerated
     */
    public likeTweet(requestParameters: TweetsApiLikeTweetRequest, options?: AxiosRequestConfig) {
        return TweetsApiFp(this.configuration).likeTweet(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of Tweets associated with the provided List ID.
     * @summary List Tweets timeline by List ID.
     * @param {TweetsApiListByListIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApiGenerated
     */
    public listByListId(requestParameters: TweetsApiListByListIdRequest, options?: AxiosRequestConfig) {
        return TweetsApiFp(this.configuration).listByListId(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of Tweets authored by the provided User ID
     * @summary User Tweets timeline by User ID
     * @param {TweetsApiListByUserIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApiGenerated
     */
    public listByUserId(requestParameters: TweetsApiListByUserIdRequest, options?: AxiosRequestConfig) {
        return TweetsApiFp(this.configuration).listByUserId(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a variety of information about the Tweet specified by the requested ID.
     * @summary Tweet lookup by Tweet ID
     * @param {TweetsApiLookupByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApiGenerated
     */
    public lookupById(requestParameters: TweetsApiLookupByIdRequest, options?: AxiosRequestConfig) {
        return TweetsApiFp(this.configuration).lookupById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a variety of information about the Tweet specified by the requested ID.
     * @summary Tweet lookup by Tweet IDs
     * @param {TweetsApiLookupByTweetIdsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApiGenerated
     */
    public lookupByTweetIds(requestParameters: TweetsApiLookupByTweetIdsRequest, options?: AxiosRequestConfig) {
        return TweetsApiFp(this.configuration).lookupByTweetIds(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Causes the User (in the path) to retweet the specified Tweet. The User in the path must match the User context authorizing the request.
     * @summary Causes the User (in the path) to retweet the specified Tweet.
     * @param {TweetsApiRetweetTweetByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApiGenerated
     */
    public retweetTweetById(requestParameters: TweetsApiRetweetTweetByIdRequest, options?: AxiosRequestConfig) {
        return TweetsApiFp(this.configuration).retweetTweetById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns Tweets that match a search query.
     * @summary Full-archive search
     * @param {TweetsApiSearchAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApiGenerated
     */
    public searchAll(requestParameters: TweetsApiSearchAllRequest, options?: AxiosRequestConfig) {
        return TweetsApiFp(this.configuration).searchAll(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns rules from a User\'s active rule set. Users can fetch all of their rules or a subset, specified by the provided rule ids.
     * @summary Rules lookup
     * @param {TweetsApiSearchStreamRulesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApiGenerated
     */
    public searchStreamRules(requestParameters: TweetsApiSearchStreamRulesRequest, options?: AxiosRequestConfig) {
        return TweetsApiFp(this.configuration).searchStreamRules(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Streams a deterministic 1% of public Tweets.
     * @summary Sample stream
     * @param {TweetsApiStreamSampleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApiGenerated
     */
    public streamSample(requestParameters: TweetsApiStreamSampleRequest = {}, options?: AxiosRequestConfig) {
        return TweetsApiFp(this.configuration).streamSample(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Streams a deterministic 10% of public Tweets.
     * @summary Sample 10% stream
     * @param {TweetsApiStreamSample10Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApiGenerated
     */
    public streamSample10(requestParameters: TweetsApiStreamSample10Request, options?: AxiosRequestConfig) {
        return TweetsApiFp(this.configuration).streamSample10(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Causes the User (in the path) to unlike the specified Tweet. The User must match the User context authorizing the request
     * @summary Causes the User (in the path) to unlike the specified Tweet
     * @param {TweetsApiUnlikeTweetByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApiGenerated
     */
    public unlikeTweetById(requestParameters: TweetsApiUnlikeTweetByIdRequest, options?: AxiosRequestConfig) {
        return TweetsApiFp(this.configuration).unlikeTweetById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Causes the User (in the path) to unretweet the specified Tweet. The User must match the User context authorizing the request
     * @summary Causes the User (in the path) to unretweet the specified Tweet
     * @param {TweetsApiUnretweetByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApiGenerated
     */
    public unretweetById(requestParameters: TweetsApiUnretweetByIdRequest, options?: AxiosRequestConfig) {
        return TweetsApiFp(this.configuration).unretweetById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
