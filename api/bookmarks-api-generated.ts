/* tslint:disable */
/* eslint-disable */
/*
Twitter API v2

Twitter API v2 available endpoints

The version of the OpenAPI document: 2.62


NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
import { setOAuthToObject } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { BookmarkAddRequest } from '../models';
// @ts-ignore
import { BookmarkMutationResponse } from '../models';
// @ts-ignore
import { Get2UsersIdBookmarksResponse } from '../models';
// @ts-ignore
import { Problem } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * BookmarksApi - axios parameter creator
 * @export
 */
export const BookmarksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a Tweet (ID in the body) to the requesting User\'s (in the path) bookmarks
         * @summary Add Tweet to Bookmarks
         * @param {string} id The ID of the authenticated source User for whom to add bookmarks.
         * @param {BookmarkAddRequest} bookmarkAddRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTweet: async (id: string, bookmarkAddRequest: BookmarkAddRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addTweet', 'id', id)
            // verify required parameter 'bookmarkAddRequest' is not null or undefined
            assertParamExists('addTweet', 'bookmarkAddRequest', bookmarkAddRequest)
            const localVarPath = `/2/users/{id}/bookmarks`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["bookmark.write", "tweet.read", "users.read"], configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: bookmarkAddRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/2/users/{id}/bookmarks',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(bookmarkAddRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns Tweet objects that have been bookmarked by the requesting User
         * @summary Bookmarks by User
         * @param {string} id The ID of the authenticated source User for whom to return results.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBookmarks: async (id: string, maxResults?: number, paginationToken?: string, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUserBookmarks', 'id', id)
            const localVarPath = `/2/users/{id}/bookmarks`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["bookmark.read", "tweet.read", "users.read"], configuration)
            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination_token'] = paginationToken;
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (mediaFields) {
                localVarQueryParameter['media.fields'] = Array.from(mediaFields).join(COLLECTION_FORMATS.csv);
            }

            if (pollFields) {
                localVarQueryParameter['poll.fields'] = Array.from(pollFields).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (placeFields) {
                localVarQueryParameter['place.fields'] = Array.from(placeFields).join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/2/users/{id}/bookmarks',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes a Tweet from the requesting User\'s bookmarked Tweets.
         * @summary Remove a bookmarked Tweet
         * @param {string} id The ID of the authenticated source User whose bookmark is to be removed.
         * @param {string} tweetId The ID of the Tweet that the source User is removing from bookmarks.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTweet: async (id: string, tweetId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('removeTweet', 'id', id)
            // verify required parameter 'tweetId' is not null or undefined
            assertParamExists('removeTweet', 'tweetId', tweetId)
            const localVarPath = `/2/users/{id}/bookmarks/{tweet_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)))
                .replace(`{${"tweet_id"}}`, encodeURIComponent(String(tweetId !== undefined ? tweetId : `-tweet_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["bookmark.write", "tweet.read", "users.read"], configuration)

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/2/users/{id}/bookmarks/{tweet_id}',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BookmarksApi - functional programming interface
 * @export
 */
export const BookmarksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BookmarksApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a Tweet (ID in the body) to the requesting User\'s (in the path) bookmarks
         * @summary Add Tweet to Bookmarks
         * @param {BookmarksApiAddTweetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addTweet(requestParameters: BookmarksApiAddTweetRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookmarkMutationResponse>> {
            const bookmarkAddRequest: BookmarkAddRequest = {
                tweet_id: requestParameters.tweet_id
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.addTweet(requestParameters.id, bookmarkAddRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns Tweet objects that have been bookmarked by the requesting User
         * @summary Bookmarks by User
         * @param {BookmarksApiGetUserBookmarksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserBookmarks(requestParameters: BookmarksApiGetUserBookmarksRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2UsersIdBookmarksResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserBookmarks(requestParameters.id, requestParameters.maxResults, requestParameters.paginationToken, requestParameters.tweetFields, requestParameters.expansions, requestParameters.mediaFields, requestParameters.pollFields, requestParameters.userFields, requestParameters.placeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes a Tweet from the requesting User\'s bookmarked Tweets.
         * @summary Remove a bookmarked Tweet
         * @param {BookmarksApiRemoveTweetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeTweet(requestParameters: BookmarksApiRemoveTweetRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookmarkMutationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeTweet(requestParameters.id, requestParameters.tweetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BookmarksApi - factory interface
 * @export
 */
export const BookmarksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BookmarksApiFp(configuration)
    return {
        /**
         * Adds a Tweet (ID in the body) to the requesting User\'s (in the path) bookmarks
         * @summary Add Tweet to Bookmarks
         * @param {BookmarksApiAddTweetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTweet(requestParameters: BookmarksApiAddTweetRequest, options?: AxiosRequestConfig): AxiosPromise<BookmarkMutationResponse> {
            return localVarFp.addTweet(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns Tweet objects that have been bookmarked by the requesting User
         * @summary Bookmarks by User
         * @param {BookmarksApiGetUserBookmarksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBookmarks(requestParameters: BookmarksApiGetUserBookmarksRequest, options?: AxiosRequestConfig): AxiosPromise<Get2UsersIdBookmarksResponse> {
            return localVarFp.getUserBookmarks(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes a Tweet from the requesting User\'s bookmarked Tweets.
         * @summary Remove a bookmarked Tweet
         * @param {BookmarksApiRemoveTweetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTweet(requestParameters: BookmarksApiRemoveTweetRequest, options?: AxiosRequestConfig): AxiosPromise<BookmarkMutationResponse> {
            return localVarFp.removeTweet(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addTweet operation in BookmarksApi.
 * @export
 * @interface BookmarksApiAddTweetRequest
 */
export type BookmarksApiAddTweetRequest = {
    
    /**
    * The ID of the authenticated source User for whom to add bookmarks.
    * @type {string}
    * @memberof BookmarksApiAddTweet
    */
    readonly id: string
    
} & BookmarkAddRequest

/**
 * Request parameters for getUserBookmarks operation in BookmarksApi.
 * @export
 * @interface BookmarksApiGetUserBookmarksRequest
 */
export type BookmarksApiGetUserBookmarksRequest = {
    
    /**
    * The ID of the authenticated source User for whom to return results.
    * @type {string}
    * @memberof BookmarksApiGetUserBookmarks
    */
    readonly id: string
    
    /**
    * The maximum number of results.
    * @type {number}
    * @memberof BookmarksApiGetUserBookmarks
    */
    readonly maxResults?: number
    
    /**
    * This parameter is used to get the next \'page\' of results.
    * @type {string}
    * @memberof BookmarksApiGetUserBookmarks
    */
    readonly paginationToken?: string
    
    /**
    * A comma separated list of Tweet fields to display.
    * @type {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>}
    * @memberof BookmarksApiGetUserBookmarks
    */
    readonly tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>
    
    /**
    * A comma separated list of fields to expand.
    * @type {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>}
    * @memberof BookmarksApiGetUserBookmarks
    */
    readonly expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>
    
    /**
    * A comma separated list of Media fields to display.
    * @type {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>}
    * @memberof BookmarksApiGetUserBookmarks
    */
    readonly mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>
    
    /**
    * A comma separated list of Poll fields to display.
    * @type {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>}
    * @memberof BookmarksApiGetUserBookmarks
    */
    readonly pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>
    
    /**
    * A comma separated list of User fields to display.
    * @type {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>}
    * @memberof BookmarksApiGetUserBookmarks
    */
    readonly userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>
    
    /**
    * A comma separated list of Place fields to display.
    * @type {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>}
    * @memberof BookmarksApiGetUserBookmarks
    */
    readonly placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>
    
}

/**
 * Request parameters for removeTweet operation in BookmarksApi.
 * @export
 * @interface BookmarksApiRemoveTweetRequest
 */
export type BookmarksApiRemoveTweetRequest = {
    
    /**
    * The ID of the authenticated source User whose bookmark is to be removed.
    * @type {string}
    * @memberof BookmarksApiRemoveTweet
    */
    readonly id: string
    
    /**
    * The ID of the Tweet that the source User is removing from bookmarks.
    * @type {string}
    * @memberof BookmarksApiRemoveTweet
    */
    readonly tweetId: string
    
}

/**
 * BookmarksApiGenerated - object-oriented interface
 * @export
 * @class BookmarksApiGenerated
 * @extends {BaseAPI}
 */
export class BookmarksApiGenerated extends BaseAPI {
    /**
     * Adds a Tweet (ID in the body) to the requesting User\'s (in the path) bookmarks
     * @summary Add Tweet to Bookmarks
     * @param {BookmarksApiAddTweetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookmarksApiGenerated
     */
    public addTweet(requestParameters: BookmarksApiAddTweetRequest, options?: AxiosRequestConfig) {
        return BookmarksApiFp(this.configuration).addTweet(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns Tweet objects that have been bookmarked by the requesting User
     * @summary Bookmarks by User
     * @param {BookmarksApiGetUserBookmarksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookmarksApiGenerated
     */
    public getUserBookmarks(requestParameters: BookmarksApiGetUserBookmarksRequest, options?: AxiosRequestConfig) {
        return BookmarksApiFp(this.configuration).getUserBookmarks(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes a Tweet from the requesting User\'s bookmarked Tweets.
     * @summary Remove a bookmarked Tweet
     * @param {BookmarksApiRemoveTweetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookmarksApiGenerated
     */
    public removeTweet(requestParameters: BookmarksApiRemoveTweetRequest, options?: AxiosRequestConfig) {
        return BookmarksApiFp(this.configuration).removeTweet(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
