/* tslint:disable */
/* eslint-disable */
/*
Twitter API v2

Twitter API v2 available endpoints

The version of the OpenAPI document: 2.62


NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
import { setOAuthToObject } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { BlockUserMutationResponse } from '../models';
// @ts-ignore
import { BlockUserRequest } from '../models';
// @ts-ignore
import { Get2ListsIdFollowersResponse } from '../models';
// @ts-ignore
import { Get2ListsIdMembersResponse } from '../models';
// @ts-ignore
import { Get2TweetsIdLikingUsersResponse } from '../models';
// @ts-ignore
import { Get2TweetsIdRetweetedByResponse } from '../models';
// @ts-ignore
import { Get2UsersByResponse } from '../models';
// @ts-ignore
import { Get2UsersByUsernameUsernameResponse } from '../models';
// @ts-ignore
import { Get2UsersIdBlockingResponse } from '../models';
// @ts-ignore
import { Get2UsersIdFollowersResponse } from '../models';
// @ts-ignore
import { Get2UsersIdFollowingResponse } from '../models';
// @ts-ignore
import { Get2UsersIdMutingResponse } from '../models';
// @ts-ignore
import { Get2UsersIdResponse } from '../models';
// @ts-ignore
import { Get2UsersMeResponse } from '../models';
// @ts-ignore
import { Get2UsersResponse } from '../models';
// @ts-ignore
import { MuteUserMutationResponse } from '../models';
// @ts-ignore
import { MuteUserRequest } from '../models';
// @ts-ignore
import { Problem } from '../models';
// @ts-ignore
import { UsersFollowingCreateRequest } from '../models';
// @ts-ignore
import { UsersFollowingCreateResponse } from '../models';
// @ts-ignore
import { UsersFollowingDeleteResponse } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Causes the User (in the path) to block the target User. The User (in the path) must match the User context authorizing the request
         * @summary Block User by User ID
         * @param {string} id The ID of the authenticated source User that is requesting to block the target User.
         * @param {BlockUserRequest} blockUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockUserById: async (id: string, blockUserRequest: BlockUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('blockUserById', 'id', id)
            // verify required parameter 'blockUserRequest' is not null or undefined
            assertParamExists('blockUserById', 'blockUserRequest', blockUserRequest)
            const localVarPath = `/2/users/{id}/blocking`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["block.write", "tweet.read", "users.read"], configuration)
            // authentication UserToken required

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: blockUserRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/2/users/{id}/blocking',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(blockUserRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Causes the User(in the path) to follow, or “request to follow” for protected Users, the target User. The User(in the path) must match the User context authorizing the request
         * @summary Follow User
         * @param {string} id The ID of the authenticated source User that is requesting to follow the target User.
         * @param {UsersFollowingCreateRequest} [usersFollowingCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followUser: async (id: string, usersFollowingCreateRequest?: UsersFollowingCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('followUser', 'id', id)
            const localVarPath = `/2/users/{id}/following`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["follows.write", "tweet.read", "users.read"], configuration)
            // authentication UserToken required

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: usersFollowingCreateRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/2/users/{id}/following',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(usersFollowingCreateRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of Users that are blocked by the provided User ID
         * @summary Returns User objects that are blocked by provided User ID
         * @param {string} id The ID of the authenticated source User for whom to return results.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockedUsers: async (id: string, maxResults?: number, paginationToken?: string, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getBlockedUsers', 'id', id)
            const localVarPath = `/2/users/{id}/blocking`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["block.read", "tweet.read", "users.read"], configuration)
            // authentication UserToken required
            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination_token'] = paginationToken;
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/2/users/{id}/blocking',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of Users who are followers of the specified User ID.
         * @summary Followers by User ID
         * @param {string} id The ID of the User to lookup.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFollowersById: async (id: string, maxResults?: number, paginationToken?: string, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFollowersById', 'id', id)
            const localVarPath = `/2/users/{id}/followers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["follows.read", "tweet.read", "users.read"], configuration)
            // authentication UserToken required
            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination_token'] = paginationToken;
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/2/users/{id}/followers',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of Users that follow a List by the provided List ID
         * @summary Returns User objects that follow a List by the provided List ID
         * @param {string} id The ID of the List.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFollowersByListId: async (id: string, maxResults?: number, paginationToken?: string, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFollowersByListId', 'id', id)
            const localVarPath = `/2/lists/{id}/followers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["list.read", "tweet.read", "users.read"], configuration)
            // authentication UserToken required
            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination_token'] = paginationToken;
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/2/lists/{id}/followers',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of Users that are being followed by the provided User ID
         * @summary Following by User ID
         * @param {string} id The ID of the User to lookup.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFollowingUsers: async (id: string, maxResults?: number, paginationToken?: string, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFollowingUsers', 'id', id)
            const localVarPath = `/2/users/{id}/following`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["follows.read", "tweet.read", "users.read"], configuration)
            // authentication UserToken required
            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination_token'] = paginationToken;
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/2/users/{id}/following',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of Users that are members of a List by the provided List ID.
         * @summary Returns User objects that are members of a List by the provided List ID.
         * @param {string} id The ID of the List.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMembersByListId: async (id: string, maxResults?: number, paginationToken?: string, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getMembersByListId', 'id', id)
            const localVarPath = `/2/lists/{id}/members`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["list.read", "tweet.read", "users.read"], configuration)
            // authentication UserToken required
            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination_token'] = paginationToken;
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/2/lists/{id}/members',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of Users that are muted by the provided User ID
         * @summary Returns User objects that are muted by the provided User ID
         * @param {string} id The ID of the authenticated source User for whom to return results.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMutedUsersById: async (id: string, maxResults?: number, paginationToken?: string, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getMutedUsersById', 'id', id)
            const localVarPath = `/2/users/{id}/muting`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["mute.read", "tweet.read", "users.read"], configuration)
            // authentication UserToken required
            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination_token'] = paginationToken;
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/2/users/{id}/muting',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of Users that have retweeted the provided Tweet ID
         * @summary Returns User objects that have retweeted the provided Tweet ID
         * @param {string} id A single Tweet ID.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRetweetedByTweetIdUsers: async (id: string, maxResults?: number, paginationToken?: string, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRetweetedByTweetIdUsers', 'id', id)
            const localVarPath = `/2/tweets/{id}/retweeted_by`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["tweet.read", "users.read"], configuration)
            // authentication UserToken required
            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination_token'] = paginationToken;
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/2/tweets/{id}/retweeted_by',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of Users that have liked the provided Tweet ID
         * @summary Returns User objects that have liked the provided Tweet ID
         * @param {string} id A single Tweet ID.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLikingUsers: async (id: string, maxResults?: number, paginationToken?: string, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listLikingUsers', 'id', id)
            const localVarPath = `/2/tweets/{id}/liking_users`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["like.read", "tweet.read", "users.read"], configuration)
            // authentication UserToken required
            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination_token'] = paginationToken;
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/2/tweets/{id}/liking_users',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns information about a User. Specify User by ID.
         * @summary User lookup by ID
         * @param {string} id The ID of the User to lookup.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupById: async (id: string, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('lookupById', 'id', id)
            const localVarPath = `/2/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["tweet.read", "users.read"], configuration)
            // authentication UserToken required
            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/2/users/{id}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns information about Users. Specify Users by their ID.
         * @summary User lookup by IDs
         * @param {Array<string>} ids A list of User IDs, comma-separated. You can specify up to 100 IDs.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupByIds: async (ids: Array<string>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('lookupByIds', 'ids', ids)
            const localVarPath = `/2/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["tweet.read", "users.read"], configuration)
            // authentication UserToken required
            if (ids) {
                localVarQueryParameter['ids'] = ids.join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/2/users',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns information about a User. Specify User by username.
         * @summary User lookup by username
         * @param {string} username A username.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupByUsername: async (username: string, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('lookupByUsername', 'username', username)
            const localVarPath = `/2/users/by/username/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username !== undefined ? username : `-username-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["tweet.read", "users.read"], configuration)
            // authentication UserToken required
            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/2/users/by/username/{username}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns information about Users. Specify Users by their username.
         * @summary User lookup by usernames
         * @param {Array<string>} usernames A list of usernames, comma-separated.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupByUsernames: async (usernames: Array<string>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'usernames' is not null or undefined
            assertParamExists('lookupByUsernames', 'usernames', usernames)
            const localVarPath = `/2/users/by`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["tweet.read", "users.read"], configuration)
            // authentication UserToken required
            if (usernames) {
                localVarQueryParameter['usernames'] = usernames.join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/2/users/by',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns information about the requesting User.
         * @summary User lookup me
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupMe: async (userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/2/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["tweet.read", "users.read"], configuration)
            // authentication UserToken required
            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/2/users/me',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Causes the User (in the path) to mute the target User. The User (in the path) must match the User context authorizing the request.
         * @summary Mute User by User ID.
         * @param {string} id The ID of the authenticated source User that is requesting to mute the target User.
         * @param {MuteUserRequest} [muteUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        muteUserById: async (id: string, muteUserRequest?: MuteUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('muteUserById', 'id', id)
            const localVarPath = `/2/users/{id}/muting`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["mute.write", "tweet.read", "users.read"], configuration)
            // authentication UserToken required

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: muteUserRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/2/users/{id}/muting',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(muteUserRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Causes the source User to unblock the target User. The source User must match the User context authorizing the request
         * @summary Unblock User by User ID
         * @param {string} sourceUserId The ID of the authenticated source User that is requesting to unblock the target User.
         * @param {string} targetUserId The ID of the User that the source User is requesting to unblock.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unblockUserById: async (sourceUserId: string, targetUserId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceUserId' is not null or undefined
            assertParamExists('unblockUserById', 'sourceUserId', sourceUserId)
            // verify required parameter 'targetUserId' is not null or undefined
            assertParamExists('unblockUserById', 'targetUserId', targetUserId)
            const localVarPath = `/2/users/{source_user_id}/blocking/{target_user_id}`
                .replace(`{${"source_user_id"}}`, encodeURIComponent(String(sourceUserId !== undefined ? sourceUserId : `-source_user_id-`)))
                .replace(`{${"target_user_id"}}`, encodeURIComponent(String(targetUserId !== undefined ? targetUserId : `-target_user_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["block.write", "tweet.read", "users.read"], configuration)
            // authentication UserToken required

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/2/users/{source_user_id}/blocking/{target_user_id}',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Causes the source User to unfollow the target User. The source User must match the User context authorizing the request
         * @summary Unfollow User
         * @param {string} sourceUserId The ID of the authenticated source User that is requesting to unfollow the target User.
         * @param {string} targetUserId The ID of the User that the source User is requesting to unfollow.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unfollowUser: async (sourceUserId: string, targetUserId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceUserId' is not null or undefined
            assertParamExists('unfollowUser', 'sourceUserId', sourceUserId)
            // verify required parameter 'targetUserId' is not null or undefined
            assertParamExists('unfollowUser', 'targetUserId', targetUserId)
            const localVarPath = `/2/users/{source_user_id}/following/{target_user_id}`
                .replace(`{${"source_user_id"}}`, encodeURIComponent(String(sourceUserId !== undefined ? sourceUserId : `-source_user_id-`)))
                .replace(`{${"target_user_id"}}`, encodeURIComponent(String(targetUserId !== undefined ? targetUserId : `-target_user_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["follows.write", "tweet.read", "users.read"], configuration)
            // authentication UserToken required

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/2/users/{source_user_id}/following/{target_user_id}',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Causes the source User to unmute the target User. The source User must match the User context authorizing the request
         * @summary Unmute User by User ID
         * @param {string} sourceUserId The ID of the authenticated source User that is requesting to unmute the target User.
         * @param {string} targetUserId The ID of the User that the source User is requesting to unmute.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unmuteByUserId: async (sourceUserId: string, targetUserId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceUserId' is not null or undefined
            assertParamExists('unmuteByUserId', 'sourceUserId', sourceUserId)
            // verify required parameter 'targetUserId' is not null or undefined
            assertParamExists('unmuteByUserId', 'targetUserId', targetUserId)
            const localVarPath = `/2/users/{source_user_id}/muting/{target_user_id}`
                .replace(`{${"source_user_id"}}`, encodeURIComponent(String(sourceUserId !== undefined ? sourceUserId : `-source_user_id-`)))
                .replace(`{${"target_user_id"}}`, encodeURIComponent(String(targetUserId !== undefined ? targetUserId : `-target_user_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["mute.write", "tweet.read", "users.read"], configuration)
            // authentication UserToken required

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/2/users/{source_user_id}/muting/{target_user_id}',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Causes the User (in the path) to block the target User. The User (in the path) must match the User context authorizing the request
         * @summary Block User by User ID
         * @param {UsersApiBlockUserByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async blockUserById(requestParameters: UsersApiBlockUserByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlockUserMutationResponse>> {
            const blockUserRequest: BlockUserRequest = {
                target_user_id: requestParameters.target_user_id
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.blockUserById(requestParameters.id, blockUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Causes the User(in the path) to follow, or “request to follow” for protected Users, the target User. The User(in the path) must match the User context authorizing the request
         * @summary Follow User
         * @param {UsersApiFollowUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async followUser(requestParameters: UsersApiFollowUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersFollowingCreateResponse>> {
            const usersFollowingCreateRequest: UsersFollowingCreateRequest = {
                target_user_id: requestParameters.target_user_id
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.followUser(requestParameters.id, usersFollowingCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of Users that are blocked by the provided User ID
         * @summary Returns User objects that are blocked by provided User ID
         * @param {UsersApiGetBlockedUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlockedUsers(requestParameters: UsersApiGetBlockedUsersRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2UsersIdBlockingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlockedUsers(requestParameters.id, requestParameters.maxResults, requestParameters.paginationToken, requestParameters.userFields, requestParameters.expansions, requestParameters.tweetFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of Users who are followers of the specified User ID.
         * @summary Followers by User ID
         * @param {UsersApiGetFollowersByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFollowersById(requestParameters: UsersApiGetFollowersByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2UsersIdFollowersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFollowersById(requestParameters.id, requestParameters.maxResults, requestParameters.paginationToken, requestParameters.userFields, requestParameters.expansions, requestParameters.tweetFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of Users that follow a List by the provided List ID
         * @summary Returns User objects that follow a List by the provided List ID
         * @param {UsersApiGetFollowersByListIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFollowersByListId(requestParameters: UsersApiGetFollowersByListIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2ListsIdFollowersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFollowersByListId(requestParameters.id, requestParameters.maxResults, requestParameters.paginationToken, requestParameters.userFields, requestParameters.expansions, requestParameters.tweetFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of Users that are being followed by the provided User ID
         * @summary Following by User ID
         * @param {UsersApiGetFollowingUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFollowingUsers(requestParameters: UsersApiGetFollowingUsersRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2UsersIdFollowingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFollowingUsers(requestParameters.id, requestParameters.maxResults, requestParameters.paginationToken, requestParameters.userFields, requestParameters.expansions, requestParameters.tweetFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of Users that are members of a List by the provided List ID.
         * @summary Returns User objects that are members of a List by the provided List ID.
         * @param {UsersApiGetMembersByListIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMembersByListId(requestParameters: UsersApiGetMembersByListIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2ListsIdMembersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMembersByListId(requestParameters.id, requestParameters.maxResults, requestParameters.paginationToken, requestParameters.userFields, requestParameters.expansions, requestParameters.tweetFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of Users that are muted by the provided User ID
         * @summary Returns User objects that are muted by the provided User ID
         * @param {UsersApiGetMutedUsersByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMutedUsersById(requestParameters: UsersApiGetMutedUsersByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2UsersIdMutingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMutedUsersById(requestParameters.id, requestParameters.maxResults, requestParameters.paginationToken, requestParameters.userFields, requestParameters.expansions, requestParameters.tweetFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of Users that have retweeted the provided Tweet ID
         * @summary Returns User objects that have retweeted the provided Tweet ID
         * @param {UsersApiGetRetweetedByTweetIdUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRetweetedByTweetIdUsers(requestParameters: UsersApiGetRetweetedByTweetIdUsersRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2TweetsIdRetweetedByResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRetweetedByTweetIdUsers(requestParameters.id, requestParameters.maxResults, requestParameters.paginationToken, requestParameters.userFields, requestParameters.expansions, requestParameters.tweetFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of Users that have liked the provided Tweet ID
         * @summary Returns User objects that have liked the provided Tweet ID
         * @param {UsersApiListLikingUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLikingUsers(requestParameters: UsersApiListLikingUsersRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2TweetsIdLikingUsersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listLikingUsers(requestParameters.id, requestParameters.maxResults, requestParameters.paginationToken, requestParameters.userFields, requestParameters.expansions, requestParameters.tweetFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns information about a User. Specify User by ID.
         * @summary User lookup by ID
         * @param {UsersApiLookupByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lookupById(requestParameters: UsersApiLookupByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2UsersIdResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupById(requestParameters.id, requestParameters.userFields, requestParameters.expansions, requestParameters.tweetFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns information about Users. Specify Users by their ID.
         * @summary User lookup by IDs
         * @param {UsersApiLookupByIdsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lookupByIds(requestParameters: UsersApiLookupByIdsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2UsersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupByIds(requestParameters.ids, requestParameters.userFields, requestParameters.expansions, requestParameters.tweetFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns information about a User. Specify User by username.
         * @summary User lookup by username
         * @param {UsersApiLookupByUsernameRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lookupByUsername(requestParameters: UsersApiLookupByUsernameRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2UsersByUsernameUsernameResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupByUsername(requestParameters.username, requestParameters.userFields, requestParameters.expansions, requestParameters.tweetFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns information about Users. Specify Users by their username.
         * @summary User lookup by usernames
         * @param {UsersApiLookupByUsernamesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lookupByUsernames(requestParameters: UsersApiLookupByUsernamesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2UsersByResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupByUsernames(requestParameters.usernames, requestParameters.userFields, requestParameters.expansions, requestParameters.tweetFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns information about the requesting User.
         * @summary User lookup me
         * @param {UsersApiLookupMeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lookupMe(requestParameters: UsersApiLookupMeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2UsersMeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupMe(requestParameters.userFields, requestParameters.expansions, requestParameters.tweetFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Causes the User (in the path) to mute the target User. The User (in the path) must match the User context authorizing the request.
         * @summary Mute User by User ID.
         * @param {UsersApiMuteUserByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async muteUserById(requestParameters: UsersApiMuteUserByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MuteUserMutationResponse>> {
            const muteUserRequest: MuteUserRequest = {
                target_user_id: requestParameters.target_user_id
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.muteUserById(requestParameters.id, muteUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Causes the source User to unblock the target User. The source User must match the User context authorizing the request
         * @summary Unblock User by User ID
         * @param {UsersApiUnblockUserByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unblockUserById(requestParameters: UsersApiUnblockUserByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlockUserMutationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unblockUserById(requestParameters.sourceUserId, requestParameters.targetUserId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Causes the source User to unfollow the target User. The source User must match the User context authorizing the request
         * @summary Unfollow User
         * @param {UsersApiUnfollowUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unfollowUser(requestParameters: UsersApiUnfollowUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersFollowingDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unfollowUser(requestParameters.sourceUserId, requestParameters.targetUserId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Causes the source User to unmute the target User. The source User must match the User context authorizing the request
         * @summary Unmute User by User ID
         * @param {UsersApiUnmuteByUserIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unmuteByUserId(requestParameters: UsersApiUnmuteByUserIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MuteUserMutationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unmuteByUserId(requestParameters.sourceUserId, requestParameters.targetUserId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Causes the User (in the path) to block the target User. The User (in the path) must match the User context authorizing the request
         * @summary Block User by User ID
         * @param {UsersApiBlockUserByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockUserById(requestParameters: UsersApiBlockUserByIdRequest, options?: AxiosRequestConfig): AxiosPromise<BlockUserMutationResponse> {
            return localVarFp.blockUserById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Causes the User(in the path) to follow, or “request to follow” for protected Users, the target User. The User(in the path) must match the User context authorizing the request
         * @summary Follow User
         * @param {UsersApiFollowUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followUser(requestParameters: UsersApiFollowUserRequest, options?: AxiosRequestConfig): AxiosPromise<UsersFollowingCreateResponse> {
            return localVarFp.followUser(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of Users that are blocked by the provided User ID
         * @summary Returns User objects that are blocked by provided User ID
         * @param {UsersApiGetBlockedUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockedUsers(requestParameters: UsersApiGetBlockedUsersRequest, options?: AxiosRequestConfig): AxiosPromise<Get2UsersIdBlockingResponse> {
            return localVarFp.getBlockedUsers(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of Users who are followers of the specified User ID.
         * @summary Followers by User ID
         * @param {UsersApiGetFollowersByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFollowersById(requestParameters: UsersApiGetFollowersByIdRequest, options?: AxiosRequestConfig): AxiosPromise<Get2UsersIdFollowersResponse> {
            return localVarFp.getFollowersById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of Users that follow a List by the provided List ID
         * @summary Returns User objects that follow a List by the provided List ID
         * @param {UsersApiGetFollowersByListIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFollowersByListId(requestParameters: UsersApiGetFollowersByListIdRequest, options?: AxiosRequestConfig): AxiosPromise<Get2ListsIdFollowersResponse> {
            return localVarFp.getFollowersByListId(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of Users that are being followed by the provided User ID
         * @summary Following by User ID
         * @param {UsersApiGetFollowingUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFollowingUsers(requestParameters: UsersApiGetFollowingUsersRequest, options?: AxiosRequestConfig): AxiosPromise<Get2UsersIdFollowingResponse> {
            return localVarFp.getFollowingUsers(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of Users that are members of a List by the provided List ID.
         * @summary Returns User objects that are members of a List by the provided List ID.
         * @param {UsersApiGetMembersByListIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMembersByListId(requestParameters: UsersApiGetMembersByListIdRequest, options?: AxiosRequestConfig): AxiosPromise<Get2ListsIdMembersResponse> {
            return localVarFp.getMembersByListId(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of Users that are muted by the provided User ID
         * @summary Returns User objects that are muted by the provided User ID
         * @param {UsersApiGetMutedUsersByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMutedUsersById(requestParameters: UsersApiGetMutedUsersByIdRequest, options?: AxiosRequestConfig): AxiosPromise<Get2UsersIdMutingResponse> {
            return localVarFp.getMutedUsersById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of Users that have retweeted the provided Tweet ID
         * @summary Returns User objects that have retweeted the provided Tweet ID
         * @param {UsersApiGetRetweetedByTweetIdUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRetweetedByTweetIdUsers(requestParameters: UsersApiGetRetweetedByTweetIdUsersRequest, options?: AxiosRequestConfig): AxiosPromise<Get2TweetsIdRetweetedByResponse> {
            return localVarFp.getRetweetedByTweetIdUsers(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of Users that have liked the provided Tweet ID
         * @summary Returns User objects that have liked the provided Tweet ID
         * @param {UsersApiListLikingUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLikingUsers(requestParameters: UsersApiListLikingUsersRequest, options?: AxiosRequestConfig): AxiosPromise<Get2TweetsIdLikingUsersResponse> {
            return localVarFp.listLikingUsers(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns information about a User. Specify User by ID.
         * @summary User lookup by ID
         * @param {UsersApiLookupByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupById(requestParameters: UsersApiLookupByIdRequest, options?: AxiosRequestConfig): AxiosPromise<Get2UsersIdResponse> {
            return localVarFp.lookupById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns information about Users. Specify Users by their ID.
         * @summary User lookup by IDs
         * @param {UsersApiLookupByIdsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupByIds(requestParameters: UsersApiLookupByIdsRequest, options?: AxiosRequestConfig): AxiosPromise<Get2UsersResponse> {
            return localVarFp.lookupByIds(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns information about a User. Specify User by username.
         * @summary User lookup by username
         * @param {UsersApiLookupByUsernameRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupByUsername(requestParameters: UsersApiLookupByUsernameRequest, options?: AxiosRequestConfig): AxiosPromise<Get2UsersByUsernameUsernameResponse> {
            return localVarFp.lookupByUsername(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns information about Users. Specify Users by their username.
         * @summary User lookup by usernames
         * @param {UsersApiLookupByUsernamesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupByUsernames(requestParameters: UsersApiLookupByUsernamesRequest, options?: AxiosRequestConfig): AxiosPromise<Get2UsersByResponse> {
            return localVarFp.lookupByUsernames(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns information about the requesting User.
         * @summary User lookup me
         * @param {UsersApiLookupMeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupMe(requestParameters: UsersApiLookupMeRequest, options?: AxiosRequestConfig): AxiosPromise<Get2UsersMeResponse> {
            return localVarFp.lookupMe(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Causes the User (in the path) to mute the target User. The User (in the path) must match the User context authorizing the request.
         * @summary Mute User by User ID.
         * @param {UsersApiMuteUserByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        muteUserById(requestParameters: UsersApiMuteUserByIdRequest, options?: AxiosRequestConfig): AxiosPromise<MuteUserMutationResponse> {
            return localVarFp.muteUserById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Causes the source User to unblock the target User. The source User must match the User context authorizing the request
         * @summary Unblock User by User ID
         * @param {UsersApiUnblockUserByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unblockUserById(requestParameters: UsersApiUnblockUserByIdRequest, options?: AxiosRequestConfig): AxiosPromise<BlockUserMutationResponse> {
            return localVarFp.unblockUserById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Causes the source User to unfollow the target User. The source User must match the User context authorizing the request
         * @summary Unfollow User
         * @param {UsersApiUnfollowUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unfollowUser(requestParameters: UsersApiUnfollowUserRequest, options?: AxiosRequestConfig): AxiosPromise<UsersFollowingDeleteResponse> {
            return localVarFp.unfollowUser(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Causes the source User to unmute the target User. The source User must match the User context authorizing the request
         * @summary Unmute User by User ID
         * @param {UsersApiUnmuteByUserIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unmuteByUserId(requestParameters: UsersApiUnmuteByUserIdRequest, options?: AxiosRequestConfig): AxiosPromise<MuteUserMutationResponse> {
            return localVarFp.unmuteByUserId(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for blockUserById operation in UsersApi.
 * @export
 * @interface UsersApiBlockUserByIdRequest
 */
export type UsersApiBlockUserByIdRequest = {
    
    /**
    * The ID of the authenticated source User that is requesting to block the target User.
    * @type {string}
    * @memberof UsersApiBlockUserById
    */
    readonly id: string
    
} & BlockUserRequest

/**
 * Request parameters for followUser operation in UsersApi.
 * @export
 * @interface UsersApiFollowUserRequest
 */
export type UsersApiFollowUserRequest = {
    
    /**
    * The ID of the authenticated source User that is requesting to follow the target User.
    * @type {string}
    * @memberof UsersApiFollowUser
    */
    readonly id: string
    
} & UsersFollowingCreateRequest

/**
 * Request parameters for getBlockedUsers operation in UsersApi.
 * @export
 * @interface UsersApiGetBlockedUsersRequest
 */
export type UsersApiGetBlockedUsersRequest = {
    
    /**
    * The ID of the authenticated source User for whom to return results.
    * @type {string}
    * @memberof UsersApiGetBlockedUsers
    */
    readonly id: string
    
    /**
    * The maximum number of results.
    * @type {number}
    * @memberof UsersApiGetBlockedUsers
    */
    readonly maxResults?: number
    
    /**
    * This parameter is used to get a specified \'page\' of results.
    * @type {string}
    * @memberof UsersApiGetBlockedUsers
    */
    readonly paginationToken?: string
    
    /**
    * A comma separated list of User fields to display.
    * @type {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>}
    * @memberof UsersApiGetBlockedUsers
    */
    readonly userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>
    
    /**
    * A comma separated list of fields to expand.
    * @type {Set<'pinned_tweet_id'>}
    * @memberof UsersApiGetBlockedUsers
    */
    readonly expansions?: Set<'pinned_tweet_id'>
    
    /**
    * A comma separated list of Tweet fields to display.
    * @type {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>}
    * @memberof UsersApiGetBlockedUsers
    */
    readonly tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>
    
}

/**
 * Request parameters for getFollowersById operation in UsersApi.
 * @export
 * @interface UsersApiGetFollowersByIdRequest
 */
export type UsersApiGetFollowersByIdRequest = {
    
    /**
    * The ID of the User to lookup.
    * @type {string}
    * @memberof UsersApiGetFollowersById
    */
    readonly id: string
    
    /**
    * The maximum number of results.
    * @type {number}
    * @memberof UsersApiGetFollowersById
    */
    readonly maxResults?: number
    
    /**
    * This parameter is used to get a specified \'page\' of results.
    * @type {string}
    * @memberof UsersApiGetFollowersById
    */
    readonly paginationToken?: string
    
    /**
    * A comma separated list of User fields to display.
    * @type {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>}
    * @memberof UsersApiGetFollowersById
    */
    readonly userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>
    
    /**
    * A comma separated list of fields to expand.
    * @type {Set<'pinned_tweet_id'>}
    * @memberof UsersApiGetFollowersById
    */
    readonly expansions?: Set<'pinned_tweet_id'>
    
    /**
    * A comma separated list of Tweet fields to display.
    * @type {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>}
    * @memberof UsersApiGetFollowersById
    */
    readonly tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>
    
}

/**
 * Request parameters for getFollowersByListId operation in UsersApi.
 * @export
 * @interface UsersApiGetFollowersByListIdRequest
 */
export type UsersApiGetFollowersByListIdRequest = {
    
    /**
    * The ID of the List.
    * @type {string}
    * @memberof UsersApiGetFollowersByListId
    */
    readonly id: string
    
    /**
    * The maximum number of results.
    * @type {number}
    * @memberof UsersApiGetFollowersByListId
    */
    readonly maxResults?: number
    
    /**
    * This parameter is used to get a specified \'page\' of results.
    * @type {string}
    * @memberof UsersApiGetFollowersByListId
    */
    readonly paginationToken?: string
    
    /**
    * A comma separated list of User fields to display.
    * @type {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>}
    * @memberof UsersApiGetFollowersByListId
    */
    readonly userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>
    
    /**
    * A comma separated list of fields to expand.
    * @type {Set<'pinned_tweet_id'>}
    * @memberof UsersApiGetFollowersByListId
    */
    readonly expansions?: Set<'pinned_tweet_id'>
    
    /**
    * A comma separated list of Tweet fields to display.
    * @type {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>}
    * @memberof UsersApiGetFollowersByListId
    */
    readonly tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>
    
}

/**
 * Request parameters for getFollowingUsers operation in UsersApi.
 * @export
 * @interface UsersApiGetFollowingUsersRequest
 */
export type UsersApiGetFollowingUsersRequest = {
    
    /**
    * The ID of the User to lookup.
    * @type {string}
    * @memberof UsersApiGetFollowingUsers
    */
    readonly id: string
    
    /**
    * The maximum number of results.
    * @type {number}
    * @memberof UsersApiGetFollowingUsers
    */
    readonly maxResults?: number
    
    /**
    * This parameter is used to get a specified \'page\' of results.
    * @type {string}
    * @memberof UsersApiGetFollowingUsers
    */
    readonly paginationToken?: string
    
    /**
    * A comma separated list of User fields to display.
    * @type {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>}
    * @memberof UsersApiGetFollowingUsers
    */
    readonly userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>
    
    /**
    * A comma separated list of fields to expand.
    * @type {Set<'pinned_tweet_id'>}
    * @memberof UsersApiGetFollowingUsers
    */
    readonly expansions?: Set<'pinned_tweet_id'>
    
    /**
    * A comma separated list of Tweet fields to display.
    * @type {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>}
    * @memberof UsersApiGetFollowingUsers
    */
    readonly tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>
    
}

/**
 * Request parameters for getMembersByListId operation in UsersApi.
 * @export
 * @interface UsersApiGetMembersByListIdRequest
 */
export type UsersApiGetMembersByListIdRequest = {
    
    /**
    * The ID of the List.
    * @type {string}
    * @memberof UsersApiGetMembersByListId
    */
    readonly id: string
    
    /**
    * The maximum number of results.
    * @type {number}
    * @memberof UsersApiGetMembersByListId
    */
    readonly maxResults?: number
    
    /**
    * This parameter is used to get a specified \'page\' of results.
    * @type {string}
    * @memberof UsersApiGetMembersByListId
    */
    readonly paginationToken?: string
    
    /**
    * A comma separated list of User fields to display.
    * @type {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>}
    * @memberof UsersApiGetMembersByListId
    */
    readonly userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>
    
    /**
    * A comma separated list of fields to expand.
    * @type {Set<'pinned_tweet_id'>}
    * @memberof UsersApiGetMembersByListId
    */
    readonly expansions?: Set<'pinned_tweet_id'>
    
    /**
    * A comma separated list of Tweet fields to display.
    * @type {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>}
    * @memberof UsersApiGetMembersByListId
    */
    readonly tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>
    
}

/**
 * Request parameters for getMutedUsersById operation in UsersApi.
 * @export
 * @interface UsersApiGetMutedUsersByIdRequest
 */
export type UsersApiGetMutedUsersByIdRequest = {
    
    /**
    * The ID of the authenticated source User for whom to return results.
    * @type {string}
    * @memberof UsersApiGetMutedUsersById
    */
    readonly id: string
    
    /**
    * The maximum number of results.
    * @type {number}
    * @memberof UsersApiGetMutedUsersById
    */
    readonly maxResults?: number
    
    /**
    * This parameter is used to get the next \'page\' of results.
    * @type {string}
    * @memberof UsersApiGetMutedUsersById
    */
    readonly paginationToken?: string
    
    /**
    * A comma separated list of User fields to display.
    * @type {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>}
    * @memberof UsersApiGetMutedUsersById
    */
    readonly userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>
    
    /**
    * A comma separated list of fields to expand.
    * @type {Set<'pinned_tweet_id'>}
    * @memberof UsersApiGetMutedUsersById
    */
    readonly expansions?: Set<'pinned_tweet_id'>
    
    /**
    * A comma separated list of Tweet fields to display.
    * @type {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>}
    * @memberof UsersApiGetMutedUsersById
    */
    readonly tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>
    
}

/**
 * Request parameters for getRetweetedByTweetIdUsers operation in UsersApi.
 * @export
 * @interface UsersApiGetRetweetedByTweetIdUsersRequest
 */
export type UsersApiGetRetweetedByTweetIdUsersRequest = {
    
    /**
    * A single Tweet ID.
    * @type {string}
    * @memberof UsersApiGetRetweetedByTweetIdUsers
    */
    readonly id: string
    
    /**
    * The maximum number of results.
    * @type {number}
    * @memberof UsersApiGetRetweetedByTweetIdUsers
    */
    readonly maxResults?: number
    
    /**
    * This parameter is used to get the next \'page\' of results.
    * @type {string}
    * @memberof UsersApiGetRetweetedByTweetIdUsers
    */
    readonly paginationToken?: string
    
    /**
    * A comma separated list of User fields to display.
    * @type {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>}
    * @memberof UsersApiGetRetweetedByTweetIdUsers
    */
    readonly userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>
    
    /**
    * A comma separated list of fields to expand.
    * @type {Set<'pinned_tweet_id'>}
    * @memberof UsersApiGetRetweetedByTweetIdUsers
    */
    readonly expansions?: Set<'pinned_tweet_id'>
    
    /**
    * A comma separated list of Tweet fields to display.
    * @type {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>}
    * @memberof UsersApiGetRetweetedByTweetIdUsers
    */
    readonly tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>
    
}

/**
 * Request parameters for listLikingUsers operation in UsersApi.
 * @export
 * @interface UsersApiListLikingUsersRequest
 */
export type UsersApiListLikingUsersRequest = {
    
    /**
    * A single Tweet ID.
    * @type {string}
    * @memberof UsersApiListLikingUsers
    */
    readonly id: string
    
    /**
    * The maximum number of results.
    * @type {number}
    * @memberof UsersApiListLikingUsers
    */
    readonly maxResults?: number
    
    /**
    * This parameter is used to get the next \'page\' of results.
    * @type {string}
    * @memberof UsersApiListLikingUsers
    */
    readonly paginationToken?: string
    
    /**
    * A comma separated list of User fields to display.
    * @type {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>}
    * @memberof UsersApiListLikingUsers
    */
    readonly userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>
    
    /**
    * A comma separated list of fields to expand.
    * @type {Set<'pinned_tweet_id'>}
    * @memberof UsersApiListLikingUsers
    */
    readonly expansions?: Set<'pinned_tweet_id'>
    
    /**
    * A comma separated list of Tweet fields to display.
    * @type {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>}
    * @memberof UsersApiListLikingUsers
    */
    readonly tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>
    
}

/**
 * Request parameters for lookupById operation in UsersApi.
 * @export
 * @interface UsersApiLookupByIdRequest
 */
export type UsersApiLookupByIdRequest = {
    
    /**
    * The ID of the User to lookup.
    * @type {string}
    * @memberof UsersApiLookupById
    */
    readonly id: string
    
    /**
    * A comma separated list of User fields to display.
    * @type {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>}
    * @memberof UsersApiLookupById
    */
    readonly userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>
    
    /**
    * A comma separated list of fields to expand.
    * @type {Set<'pinned_tweet_id'>}
    * @memberof UsersApiLookupById
    */
    readonly expansions?: Set<'pinned_tweet_id'>
    
    /**
    * A comma separated list of Tweet fields to display.
    * @type {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>}
    * @memberof UsersApiLookupById
    */
    readonly tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>
    
}

/**
 * Request parameters for lookupByIds operation in UsersApi.
 * @export
 * @interface UsersApiLookupByIdsRequest
 */
export type UsersApiLookupByIdsRequest = {
    
    /**
    * A list of User IDs, comma-separated. You can specify up to 100 IDs.
    * @type {Array<string>}
    * @memberof UsersApiLookupByIds
    */
    readonly ids: Array<string>
    
    /**
    * A comma separated list of User fields to display.
    * @type {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>}
    * @memberof UsersApiLookupByIds
    */
    readonly userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>
    
    /**
    * A comma separated list of fields to expand.
    * @type {Set<'pinned_tweet_id'>}
    * @memberof UsersApiLookupByIds
    */
    readonly expansions?: Set<'pinned_tweet_id'>
    
    /**
    * A comma separated list of Tweet fields to display.
    * @type {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>}
    * @memberof UsersApiLookupByIds
    */
    readonly tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>
    
}

/**
 * Request parameters for lookupByUsername operation in UsersApi.
 * @export
 * @interface UsersApiLookupByUsernameRequest
 */
export type UsersApiLookupByUsernameRequest = {
    
    /**
    * A username.
    * @type {string}
    * @memberof UsersApiLookupByUsername
    */
    readonly username: string
    
    /**
    * A comma separated list of User fields to display.
    * @type {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>}
    * @memberof UsersApiLookupByUsername
    */
    readonly userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>
    
    /**
    * A comma separated list of fields to expand.
    * @type {Set<'pinned_tweet_id'>}
    * @memberof UsersApiLookupByUsername
    */
    readonly expansions?: Set<'pinned_tweet_id'>
    
    /**
    * A comma separated list of Tweet fields to display.
    * @type {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>}
    * @memberof UsersApiLookupByUsername
    */
    readonly tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>
    
}

/**
 * Request parameters for lookupByUsernames operation in UsersApi.
 * @export
 * @interface UsersApiLookupByUsernamesRequest
 */
export type UsersApiLookupByUsernamesRequest = {
    
    /**
    * A list of usernames, comma-separated.
    * @type {Array<string>}
    * @memberof UsersApiLookupByUsernames
    */
    readonly usernames: Array<string>
    
    /**
    * A comma separated list of User fields to display.
    * @type {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>}
    * @memberof UsersApiLookupByUsernames
    */
    readonly userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>
    
    /**
    * A comma separated list of fields to expand.
    * @type {Set<'pinned_tweet_id'>}
    * @memberof UsersApiLookupByUsernames
    */
    readonly expansions?: Set<'pinned_tweet_id'>
    
    /**
    * A comma separated list of Tweet fields to display.
    * @type {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>}
    * @memberof UsersApiLookupByUsernames
    */
    readonly tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>
    
}

/**
 * Request parameters for lookupMe operation in UsersApi.
 * @export
 * @interface UsersApiLookupMeRequest
 */
export type UsersApiLookupMeRequest = {
    
    /**
    * A comma separated list of User fields to display.
    * @type {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>}
    * @memberof UsersApiLookupMe
    */
    readonly userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>
    
    /**
    * A comma separated list of fields to expand.
    * @type {Set<'pinned_tweet_id'>}
    * @memberof UsersApiLookupMe
    */
    readonly expansions?: Set<'pinned_tweet_id'>
    
    /**
    * A comma separated list of Tweet fields to display.
    * @type {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>}
    * @memberof UsersApiLookupMe
    */
    readonly tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>
    
}

/**
 * Request parameters for muteUserById operation in UsersApi.
 * @export
 * @interface UsersApiMuteUserByIdRequest
 */
export type UsersApiMuteUserByIdRequest = {
    
    /**
    * The ID of the authenticated source User that is requesting to mute the target User.
    * @type {string}
    * @memberof UsersApiMuteUserById
    */
    readonly id: string
    
} & MuteUserRequest

/**
 * Request parameters for unblockUserById operation in UsersApi.
 * @export
 * @interface UsersApiUnblockUserByIdRequest
 */
export type UsersApiUnblockUserByIdRequest = {
    
    /**
    * The ID of the authenticated source User that is requesting to unblock the target User.
    * @type {string}
    * @memberof UsersApiUnblockUserById
    */
    readonly sourceUserId: string
    
    /**
    * The ID of the User that the source User is requesting to unblock.
    * @type {string}
    * @memberof UsersApiUnblockUserById
    */
    readonly targetUserId: string
    
}

/**
 * Request parameters for unfollowUser operation in UsersApi.
 * @export
 * @interface UsersApiUnfollowUserRequest
 */
export type UsersApiUnfollowUserRequest = {
    
    /**
    * The ID of the authenticated source User that is requesting to unfollow the target User.
    * @type {string}
    * @memberof UsersApiUnfollowUser
    */
    readonly sourceUserId: string
    
    /**
    * The ID of the User that the source User is requesting to unfollow.
    * @type {string}
    * @memberof UsersApiUnfollowUser
    */
    readonly targetUserId: string
    
}

/**
 * Request parameters for unmuteByUserId operation in UsersApi.
 * @export
 * @interface UsersApiUnmuteByUserIdRequest
 */
export type UsersApiUnmuteByUserIdRequest = {
    
    /**
    * The ID of the authenticated source User that is requesting to unmute the target User.
    * @type {string}
    * @memberof UsersApiUnmuteByUserId
    */
    readonly sourceUserId: string
    
    /**
    * The ID of the User that the source User is requesting to unmute.
    * @type {string}
    * @memberof UsersApiUnmuteByUserId
    */
    readonly targetUserId: string
    
}

/**
 * UsersApiGenerated - object-oriented interface
 * @export
 * @class UsersApiGenerated
 * @extends {BaseAPI}
 */
export class UsersApiGenerated extends BaseAPI {
    /**
     * Causes the User (in the path) to block the target User. The User (in the path) must match the User context authorizing the request
     * @summary Block User by User ID
     * @param {UsersApiBlockUserByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public blockUserById(requestParameters: UsersApiBlockUserByIdRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).blockUserById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Causes the User(in the path) to follow, or “request to follow” for protected Users, the target User. The User(in the path) must match the User context authorizing the request
     * @summary Follow User
     * @param {UsersApiFollowUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public followUser(requestParameters: UsersApiFollowUserRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).followUser(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of Users that are blocked by the provided User ID
     * @summary Returns User objects that are blocked by provided User ID
     * @param {UsersApiGetBlockedUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public getBlockedUsers(requestParameters: UsersApiGetBlockedUsersRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getBlockedUsers(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of Users who are followers of the specified User ID.
     * @summary Followers by User ID
     * @param {UsersApiGetFollowersByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public getFollowersById(requestParameters: UsersApiGetFollowersByIdRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getFollowersById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of Users that follow a List by the provided List ID
     * @summary Returns User objects that follow a List by the provided List ID
     * @param {UsersApiGetFollowersByListIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public getFollowersByListId(requestParameters: UsersApiGetFollowersByListIdRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getFollowersByListId(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of Users that are being followed by the provided User ID
     * @summary Following by User ID
     * @param {UsersApiGetFollowingUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public getFollowingUsers(requestParameters: UsersApiGetFollowingUsersRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getFollowingUsers(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of Users that are members of a List by the provided List ID.
     * @summary Returns User objects that are members of a List by the provided List ID.
     * @param {UsersApiGetMembersByListIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public getMembersByListId(requestParameters: UsersApiGetMembersByListIdRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getMembersByListId(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of Users that are muted by the provided User ID
     * @summary Returns User objects that are muted by the provided User ID
     * @param {UsersApiGetMutedUsersByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public getMutedUsersById(requestParameters: UsersApiGetMutedUsersByIdRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getMutedUsersById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of Users that have retweeted the provided Tweet ID
     * @summary Returns User objects that have retweeted the provided Tweet ID
     * @param {UsersApiGetRetweetedByTweetIdUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public getRetweetedByTweetIdUsers(requestParameters: UsersApiGetRetweetedByTweetIdUsersRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getRetweetedByTweetIdUsers(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of Users that have liked the provided Tweet ID
     * @summary Returns User objects that have liked the provided Tweet ID
     * @param {UsersApiListLikingUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public listLikingUsers(requestParameters: UsersApiListLikingUsersRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).listLikingUsers(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns information about a User. Specify User by ID.
     * @summary User lookup by ID
     * @param {UsersApiLookupByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public lookupById(requestParameters: UsersApiLookupByIdRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).lookupById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns information about Users. Specify Users by their ID.
     * @summary User lookup by IDs
     * @param {UsersApiLookupByIdsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public lookupByIds(requestParameters: UsersApiLookupByIdsRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).lookupByIds(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns information about a User. Specify User by username.
     * @summary User lookup by username
     * @param {UsersApiLookupByUsernameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public lookupByUsername(requestParameters: UsersApiLookupByUsernameRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).lookupByUsername(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns information about Users. Specify Users by their username.
     * @summary User lookup by usernames
     * @param {UsersApiLookupByUsernamesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public lookupByUsernames(requestParameters: UsersApiLookupByUsernamesRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).lookupByUsernames(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns information about the requesting User.
     * @summary User lookup me
     * @param {UsersApiLookupMeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public lookupMe(requestParameters: UsersApiLookupMeRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).lookupMe(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Causes the User (in the path) to mute the target User. The User (in the path) must match the User context authorizing the request.
     * @summary Mute User by User ID.
     * @param {UsersApiMuteUserByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public muteUserById(requestParameters: UsersApiMuteUserByIdRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).muteUserById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Causes the source User to unblock the target User. The source User must match the User context authorizing the request
     * @summary Unblock User by User ID
     * @param {UsersApiUnblockUserByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public unblockUserById(requestParameters: UsersApiUnblockUserByIdRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).unblockUserById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Causes the source User to unfollow the target User. The source User must match the User context authorizing the request
     * @summary Unfollow User
     * @param {UsersApiUnfollowUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public unfollowUser(requestParameters: UsersApiUnfollowUserRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).unfollowUser(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Causes the source User to unmute the target User. The source User must match the User context authorizing the request
     * @summary Unmute User by User ID
     * @param {UsersApiUnmuteByUserIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public unmuteByUserId(requestParameters: UsersApiUnmuteByUserIdRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).unmuteByUserId(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
