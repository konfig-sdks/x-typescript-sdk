/* tslint:disable */
/* eslint-disable */
/*
Twitter API v2

Twitter API v2 available endpoints

The version of the OpenAPI document: 2.62


NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
import { setOAuthToObject } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { Get2SpacesByCreatorIdsResponse } from '../models';
// @ts-ignore
import { Get2SpacesIdBuyersResponse } from '../models';
// @ts-ignore
import { Get2SpacesIdResponse } from '../models';
// @ts-ignore
import { Get2SpacesIdTweetsResponse } from '../models';
// @ts-ignore
import { Get2SpacesResponse } from '../models';
// @ts-ignore
import { Get2SpacesSearchResponse } from '../models';
// @ts-ignore
import { Problem } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * SpacesApi - axios parameter creator
 * @export
 */
export const SpacesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns Spaces that match the provided query.
         * @summary Search for Spaces
         * @param {string} query The search query.
         * @param {'live' | 'scheduled' | 'all'} [state] The state of Spaces to search for.
         * @param {number} [maxResults] The number of results to return.
         * @param {Set<'created_at' | 'creator_id' | 'ended_at' | 'host_ids' | 'id' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'state' | 'subscriber_count' | 'title' | 'topic_ids' | 'updated_at'>} [spaceFields] A comma separated list of Space fields to display.
         * @param {Set<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids' | 'topic_ids'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'description' | 'id' | 'name'>} [topicFields] A comma separated list of Topic fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMatchingSpaces: async (query: string, state?: 'live' | 'scheduled' | 'all', maxResults?: number, spaceFields?: Set<'created_at' | 'creator_id' | 'ended_at' | 'host_ids' | 'id' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'state' | 'subscriber_count' | 'title' | 'topic_ids' | 'updated_at'>, expansions?: Set<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids' | 'topic_ids'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, topicFields?: Set<'description' | 'id' | 'name'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            assertParamExists('findMatchingSpaces', 'query', query)
            const localVarPath = `/2/spaces/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["space.read", "tweet.read", "users.read"], configuration)
            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (spaceFields) {
                localVarQueryParameter['space.fields'] = Array.from(spaceFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (topicFields) {
                localVarQueryParameter['topic.fields'] = Array.from(topicFields).join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/2/spaces/search',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of Users who purchased a ticket to the given space
         * @summary Retrieve the list of Users who purchased a ticket to the given space
         * @param {string} id The ID of the Space to be retrieved.
         * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
         * @param {number} [maxResults] The maximum number of results.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBuyersList: async (id: string, paginationToken?: string, maxResults?: number, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getBuyersList', 'id', id)
            const localVarPath = `/2/spaces/{id}/buyers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["space.read", "tweet.read", "users.read"], configuration)
            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination_token'] = paginationToken;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/2/spaces/{id}/buyers',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves Tweets shared in the specified Space.
         * @summary Retrieve Tweets from a Space.
         * @param {string} id The ID of the Space to be retrieved.
         * @param {number} [maxResults] The number of Tweets to fetch from the provided space. If not provided, the value will default to the maximum of 100.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTweets: async (id: string, maxResults?: number, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTweets', 'id', id)
            const localVarPath = `/2/spaces/{id}/tweets`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["space.read", "tweet.read", "users.read"], configuration)
            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (mediaFields) {
                localVarQueryParameter['media.fields'] = Array.from(mediaFields).join(COLLECTION_FORMATS.csv);
            }

            if (pollFields) {
                localVarQueryParameter['poll.fields'] = Array.from(pollFields).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (placeFields) {
                localVarQueryParameter['place.fields'] = Array.from(placeFields).join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/2/spaces/{id}/tweets',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a variety of information about the Spaces created by the provided User IDs
         * @summary Space lookup by their creators
         * @param {Array<string>} userIds The IDs of Users to search through.
         * @param {Set<'created_at' | 'creator_id' | 'ended_at' | 'host_ids' | 'id' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'state' | 'subscriber_count' | 'title' | 'topic_ids' | 'updated_at'>} [spaceFields] A comma separated list of Space fields to display.
         * @param {Set<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids' | 'topic_ids'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'description' | 'id' | 'name'>} [topicFields] A comma separated list of Topic fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupByCreatorIds: async (userIds: Array<string>, spaceFields?: Set<'created_at' | 'creator_id' | 'ended_at' | 'host_ids' | 'id' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'state' | 'subscriber_count' | 'title' | 'topic_ids' | 'updated_at'>, expansions?: Set<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids' | 'topic_ids'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, topicFields?: Set<'description' | 'id' | 'name'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userIds' is not null or undefined
            assertParamExists('lookupByCreatorIds', 'userIds', userIds)
            const localVarPath = `/2/spaces/by/creator_ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["space.read", "tweet.read", "users.read"], configuration)
            if (userIds) {
                localVarQueryParameter['user_ids'] = userIds;
            }

            if (spaceFields) {
                localVarQueryParameter['space.fields'] = Array.from(spaceFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (topicFields) {
                localVarQueryParameter['topic.fields'] = Array.from(topicFields).join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/2/spaces/by/creator_ids',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a variety of information about the Space specified by the requested ID
         * @summary Space lookup by Space ID
         * @param {string} id The ID of the Space to be retrieved.
         * @param {Set<'created_at' | 'creator_id' | 'ended_at' | 'host_ids' | 'id' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'state' | 'subscriber_count' | 'title' | 'topic_ids' | 'updated_at'>} [spaceFields] A comma separated list of Space fields to display.
         * @param {Set<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids' | 'topic_ids'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'description' | 'id' | 'name'>} [topicFields] A comma separated list of Topic fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupSpaceById: async (id: string, spaceFields?: Set<'created_at' | 'creator_id' | 'ended_at' | 'host_ids' | 'id' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'state' | 'subscriber_count' | 'title' | 'topic_ids' | 'updated_at'>, expansions?: Set<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids' | 'topic_ids'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, topicFields?: Set<'description' | 'id' | 'name'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('lookupSpaceById', 'id', id)
            const localVarPath = `/2/spaces/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["space.read", "tweet.read", "users.read"], configuration)
            if (spaceFields) {
                localVarQueryParameter['space.fields'] = Array.from(spaceFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (topicFields) {
                localVarQueryParameter['topic.fields'] = Array.from(topicFields).join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/2/spaces/{id}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a variety of information about the Spaces specified by the requested IDs
         * @summary Space lookup up Space IDs
         * @param {Array<string>} ids The list of Space IDs to return.
         * @param {Set<'created_at' | 'creator_id' | 'ended_at' | 'host_ids' | 'id' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'state' | 'subscriber_count' | 'title' | 'topic_ids' | 'updated_at'>} [spaceFields] A comma separated list of Space fields to display.
         * @param {Set<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids' | 'topic_ids'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'description' | 'id' | 'name'>} [topicFields] A comma separated list of Topic fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupSpaceIds: async (ids: Array<string>, spaceFields?: Set<'created_at' | 'creator_id' | 'ended_at' | 'host_ids' | 'id' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'state' | 'subscriber_count' | 'title' | 'topic_ids' | 'updated_at'>, expansions?: Set<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids' | 'topic_ids'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, topicFields?: Set<'description' | 'id' | 'name'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('lookupSpaceIds', 'ids', ids)
            const localVarPath = `/2/spaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["space.read", "tweet.read", "users.read"], configuration)
            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }

            if (spaceFields) {
                localVarQueryParameter['space.fields'] = Array.from(spaceFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (topicFields) {
                localVarQueryParameter['topic.fields'] = Array.from(topicFields).join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/2/spaces',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SpacesApi - functional programming interface
 * @export
 */
export const SpacesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SpacesApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns Spaces that match the provided query.
         * @summary Search for Spaces
         * @param {SpacesApiFindMatchingSpacesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findMatchingSpaces(requestParameters: SpacesApiFindMatchingSpacesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2SpacesSearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findMatchingSpaces(requestParameters.query, requestParameters.state, requestParameters.maxResults, requestParameters.spaceFields, requestParameters.expansions, requestParameters.userFields, requestParameters.topicFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of Users who purchased a ticket to the given space
         * @summary Retrieve the list of Users who purchased a ticket to the given space
         * @param {SpacesApiGetBuyersListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBuyersList(requestParameters: SpacesApiGetBuyersListRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2SpacesIdBuyersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBuyersList(requestParameters.id, requestParameters.paginationToken, requestParameters.maxResults, requestParameters.userFields, requestParameters.expansions, requestParameters.tweetFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves Tweets shared in the specified Space.
         * @summary Retrieve Tweets from a Space.
         * @param {SpacesApiGetTweetsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTweets(requestParameters: SpacesApiGetTweetsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2SpacesIdTweetsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTweets(requestParameters.id, requestParameters.maxResults, requestParameters.tweetFields, requestParameters.expansions, requestParameters.mediaFields, requestParameters.pollFields, requestParameters.userFields, requestParameters.placeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a variety of information about the Spaces created by the provided User IDs
         * @summary Space lookup by their creators
         * @param {SpacesApiLookupByCreatorIdsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lookupByCreatorIds(requestParameters: SpacesApiLookupByCreatorIdsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2SpacesByCreatorIdsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupByCreatorIds(requestParameters.userIds, requestParameters.spaceFields, requestParameters.expansions, requestParameters.userFields, requestParameters.topicFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a variety of information about the Space specified by the requested ID
         * @summary Space lookup by Space ID
         * @param {SpacesApiLookupSpaceByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lookupSpaceById(requestParameters: SpacesApiLookupSpaceByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2SpacesIdResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupSpaceById(requestParameters.id, requestParameters.spaceFields, requestParameters.expansions, requestParameters.userFields, requestParameters.topicFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a variety of information about the Spaces specified by the requested IDs
         * @summary Space lookup up Space IDs
         * @param {SpacesApiLookupSpaceIdsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lookupSpaceIds(requestParameters: SpacesApiLookupSpaceIdsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2SpacesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupSpaceIds(requestParameters.ids, requestParameters.spaceFields, requestParameters.expansions, requestParameters.userFields, requestParameters.topicFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SpacesApi - factory interface
 * @export
 */
export const SpacesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SpacesApiFp(configuration)
    return {
        /**
         * Returns Spaces that match the provided query.
         * @summary Search for Spaces
         * @param {SpacesApiFindMatchingSpacesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMatchingSpaces(requestParameters: SpacesApiFindMatchingSpacesRequest, options?: AxiosRequestConfig): AxiosPromise<Get2SpacesSearchResponse> {
            return localVarFp.findMatchingSpaces(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of Users who purchased a ticket to the given space
         * @summary Retrieve the list of Users who purchased a ticket to the given space
         * @param {SpacesApiGetBuyersListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBuyersList(requestParameters: SpacesApiGetBuyersListRequest, options?: AxiosRequestConfig): AxiosPromise<Get2SpacesIdBuyersResponse> {
            return localVarFp.getBuyersList(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves Tweets shared in the specified Space.
         * @summary Retrieve Tweets from a Space.
         * @param {SpacesApiGetTweetsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTweets(requestParameters: SpacesApiGetTweetsRequest, options?: AxiosRequestConfig): AxiosPromise<Get2SpacesIdTweetsResponse> {
            return localVarFp.getTweets(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a variety of information about the Spaces created by the provided User IDs
         * @summary Space lookup by their creators
         * @param {SpacesApiLookupByCreatorIdsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupByCreatorIds(requestParameters: SpacesApiLookupByCreatorIdsRequest, options?: AxiosRequestConfig): AxiosPromise<Get2SpacesByCreatorIdsResponse> {
            return localVarFp.lookupByCreatorIds(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a variety of information about the Space specified by the requested ID
         * @summary Space lookup by Space ID
         * @param {SpacesApiLookupSpaceByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupSpaceById(requestParameters: SpacesApiLookupSpaceByIdRequest, options?: AxiosRequestConfig): AxiosPromise<Get2SpacesIdResponse> {
            return localVarFp.lookupSpaceById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a variety of information about the Spaces specified by the requested IDs
         * @summary Space lookup up Space IDs
         * @param {SpacesApiLookupSpaceIdsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupSpaceIds(requestParameters: SpacesApiLookupSpaceIdsRequest, options?: AxiosRequestConfig): AxiosPromise<Get2SpacesResponse> {
            return localVarFp.lookupSpaceIds(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for findMatchingSpaces operation in SpacesApi.
 * @export
 * @interface SpacesApiFindMatchingSpacesRequest
 */
export type SpacesApiFindMatchingSpacesRequest = {
    
    /**
    * The search query.
    * @type {string}
    * @memberof SpacesApiFindMatchingSpaces
    */
    readonly query: string
    
    /**
    * The state of Spaces to search for.
    * @type {'live' | 'scheduled' | 'all'}
    * @memberof SpacesApiFindMatchingSpaces
    */
    readonly state?: 'live' | 'scheduled' | 'all'
    
    /**
    * The number of results to return.
    * @type {number}
    * @memberof SpacesApiFindMatchingSpaces
    */
    readonly maxResults?: number
    
    /**
    * A comma separated list of Space fields to display.
    * @type {Set<'created_at' | 'creator_id' | 'ended_at' | 'host_ids' | 'id' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'state' | 'subscriber_count' | 'title' | 'topic_ids' | 'updated_at'>}
    * @memberof SpacesApiFindMatchingSpaces
    */
    readonly spaceFields?: Set<'created_at' | 'creator_id' | 'ended_at' | 'host_ids' | 'id' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'state' | 'subscriber_count' | 'title' | 'topic_ids' | 'updated_at'>
    
    /**
    * A comma separated list of fields to expand.
    * @type {Set<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids' | 'topic_ids'>}
    * @memberof SpacesApiFindMatchingSpaces
    */
    readonly expansions?: Set<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids' | 'topic_ids'>
    
    /**
    * A comma separated list of User fields to display.
    * @type {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>}
    * @memberof SpacesApiFindMatchingSpaces
    */
    readonly userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>
    
    /**
    * A comma separated list of Topic fields to display.
    * @type {Set<'description' | 'id' | 'name'>}
    * @memberof SpacesApiFindMatchingSpaces
    */
    readonly topicFields?: Set<'description' | 'id' | 'name'>
    
}

/**
 * Request parameters for getBuyersList operation in SpacesApi.
 * @export
 * @interface SpacesApiGetBuyersListRequest
 */
export type SpacesApiGetBuyersListRequest = {
    
    /**
    * The ID of the Space to be retrieved.
    * @type {string}
    * @memberof SpacesApiGetBuyersList
    */
    readonly id: string
    
    /**
    * This parameter is used to get a specified \'page\' of results.
    * @type {string}
    * @memberof SpacesApiGetBuyersList
    */
    readonly paginationToken?: string
    
    /**
    * The maximum number of results.
    * @type {number}
    * @memberof SpacesApiGetBuyersList
    */
    readonly maxResults?: number
    
    /**
    * A comma separated list of User fields to display.
    * @type {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>}
    * @memberof SpacesApiGetBuyersList
    */
    readonly userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>
    
    /**
    * A comma separated list of fields to expand.
    * @type {Set<'pinned_tweet_id'>}
    * @memberof SpacesApiGetBuyersList
    */
    readonly expansions?: Set<'pinned_tweet_id'>
    
    /**
    * A comma separated list of Tweet fields to display.
    * @type {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>}
    * @memberof SpacesApiGetBuyersList
    */
    readonly tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>
    
}

/**
 * Request parameters for getTweets operation in SpacesApi.
 * @export
 * @interface SpacesApiGetTweetsRequest
 */
export type SpacesApiGetTweetsRequest = {
    
    /**
    * The ID of the Space to be retrieved.
    * @type {string}
    * @memberof SpacesApiGetTweets
    */
    readonly id: string
    
    /**
    * The number of Tweets to fetch from the provided space. If not provided, the value will default to the maximum of 100.
    * @type {number}
    * @memberof SpacesApiGetTweets
    */
    readonly maxResults?: number
    
    /**
    * A comma separated list of Tweet fields to display.
    * @type {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>}
    * @memberof SpacesApiGetTweets
    */
    readonly tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>
    
    /**
    * A comma separated list of fields to expand.
    * @type {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>}
    * @memberof SpacesApiGetTweets
    */
    readonly expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>
    
    /**
    * A comma separated list of Media fields to display.
    * @type {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>}
    * @memberof SpacesApiGetTweets
    */
    readonly mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>
    
    /**
    * A comma separated list of Poll fields to display.
    * @type {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>}
    * @memberof SpacesApiGetTweets
    */
    readonly pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>
    
    /**
    * A comma separated list of User fields to display.
    * @type {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>}
    * @memberof SpacesApiGetTweets
    */
    readonly userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>
    
    /**
    * A comma separated list of Place fields to display.
    * @type {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>}
    * @memberof SpacesApiGetTweets
    */
    readonly placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>
    
}

/**
 * Request parameters for lookupByCreatorIds operation in SpacesApi.
 * @export
 * @interface SpacesApiLookupByCreatorIdsRequest
 */
export type SpacesApiLookupByCreatorIdsRequest = {
    
    /**
    * The IDs of Users to search through.
    * @type {Array<string>}
    * @memberof SpacesApiLookupByCreatorIds
    */
    readonly userIds: Array<string>
    
    /**
    * A comma separated list of Space fields to display.
    * @type {Set<'created_at' | 'creator_id' | 'ended_at' | 'host_ids' | 'id' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'state' | 'subscriber_count' | 'title' | 'topic_ids' | 'updated_at'>}
    * @memberof SpacesApiLookupByCreatorIds
    */
    readonly spaceFields?: Set<'created_at' | 'creator_id' | 'ended_at' | 'host_ids' | 'id' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'state' | 'subscriber_count' | 'title' | 'topic_ids' | 'updated_at'>
    
    /**
    * A comma separated list of fields to expand.
    * @type {Set<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids' | 'topic_ids'>}
    * @memberof SpacesApiLookupByCreatorIds
    */
    readonly expansions?: Set<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids' | 'topic_ids'>
    
    /**
    * A comma separated list of User fields to display.
    * @type {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>}
    * @memberof SpacesApiLookupByCreatorIds
    */
    readonly userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>
    
    /**
    * A comma separated list of Topic fields to display.
    * @type {Set<'description' | 'id' | 'name'>}
    * @memberof SpacesApiLookupByCreatorIds
    */
    readonly topicFields?: Set<'description' | 'id' | 'name'>
    
}

/**
 * Request parameters for lookupSpaceById operation in SpacesApi.
 * @export
 * @interface SpacesApiLookupSpaceByIdRequest
 */
export type SpacesApiLookupSpaceByIdRequest = {
    
    /**
    * The ID of the Space to be retrieved.
    * @type {string}
    * @memberof SpacesApiLookupSpaceById
    */
    readonly id: string
    
    /**
    * A comma separated list of Space fields to display.
    * @type {Set<'created_at' | 'creator_id' | 'ended_at' | 'host_ids' | 'id' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'state' | 'subscriber_count' | 'title' | 'topic_ids' | 'updated_at'>}
    * @memberof SpacesApiLookupSpaceById
    */
    readonly spaceFields?: Set<'created_at' | 'creator_id' | 'ended_at' | 'host_ids' | 'id' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'state' | 'subscriber_count' | 'title' | 'topic_ids' | 'updated_at'>
    
    /**
    * A comma separated list of fields to expand.
    * @type {Set<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids' | 'topic_ids'>}
    * @memberof SpacesApiLookupSpaceById
    */
    readonly expansions?: Set<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids' | 'topic_ids'>
    
    /**
    * A comma separated list of User fields to display.
    * @type {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>}
    * @memberof SpacesApiLookupSpaceById
    */
    readonly userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>
    
    /**
    * A comma separated list of Topic fields to display.
    * @type {Set<'description' | 'id' | 'name'>}
    * @memberof SpacesApiLookupSpaceById
    */
    readonly topicFields?: Set<'description' | 'id' | 'name'>
    
}

/**
 * Request parameters for lookupSpaceIds operation in SpacesApi.
 * @export
 * @interface SpacesApiLookupSpaceIdsRequest
 */
export type SpacesApiLookupSpaceIdsRequest = {
    
    /**
    * The list of Space IDs to return.
    * @type {Array<string>}
    * @memberof SpacesApiLookupSpaceIds
    */
    readonly ids: Array<string>
    
    /**
    * A comma separated list of Space fields to display.
    * @type {Set<'created_at' | 'creator_id' | 'ended_at' | 'host_ids' | 'id' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'state' | 'subscriber_count' | 'title' | 'topic_ids' | 'updated_at'>}
    * @memberof SpacesApiLookupSpaceIds
    */
    readonly spaceFields?: Set<'created_at' | 'creator_id' | 'ended_at' | 'host_ids' | 'id' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'state' | 'subscriber_count' | 'title' | 'topic_ids' | 'updated_at'>
    
    /**
    * A comma separated list of fields to expand.
    * @type {Set<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids' | 'topic_ids'>}
    * @memberof SpacesApiLookupSpaceIds
    */
    readonly expansions?: Set<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids' | 'topic_ids'>
    
    /**
    * A comma separated list of User fields to display.
    * @type {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>}
    * @memberof SpacesApiLookupSpaceIds
    */
    readonly userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>
    
    /**
    * A comma separated list of Topic fields to display.
    * @type {Set<'description' | 'id' | 'name'>}
    * @memberof SpacesApiLookupSpaceIds
    */
    readonly topicFields?: Set<'description' | 'id' | 'name'>
    
}

/**
 * SpacesApiGenerated - object-oriented interface
 * @export
 * @class SpacesApiGenerated
 * @extends {BaseAPI}
 */
export class SpacesApiGenerated extends BaseAPI {
    /**
     * Returns Spaces that match the provided query.
     * @summary Search for Spaces
     * @param {SpacesApiFindMatchingSpacesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpacesApiGenerated
     */
    public findMatchingSpaces(requestParameters: SpacesApiFindMatchingSpacesRequest, options?: AxiosRequestConfig) {
        return SpacesApiFp(this.configuration).findMatchingSpaces(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of Users who purchased a ticket to the given space
     * @summary Retrieve the list of Users who purchased a ticket to the given space
     * @param {SpacesApiGetBuyersListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpacesApiGenerated
     */
    public getBuyersList(requestParameters: SpacesApiGetBuyersListRequest, options?: AxiosRequestConfig) {
        return SpacesApiFp(this.configuration).getBuyersList(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves Tweets shared in the specified Space.
     * @summary Retrieve Tweets from a Space.
     * @param {SpacesApiGetTweetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpacesApiGenerated
     */
    public getTweets(requestParameters: SpacesApiGetTweetsRequest, options?: AxiosRequestConfig) {
        return SpacesApiFp(this.configuration).getTweets(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a variety of information about the Spaces created by the provided User IDs
     * @summary Space lookup by their creators
     * @param {SpacesApiLookupByCreatorIdsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpacesApiGenerated
     */
    public lookupByCreatorIds(requestParameters: SpacesApiLookupByCreatorIdsRequest, options?: AxiosRequestConfig) {
        return SpacesApiFp(this.configuration).lookupByCreatorIds(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a variety of information about the Space specified by the requested ID
     * @summary Space lookup by Space ID
     * @param {SpacesApiLookupSpaceByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpacesApiGenerated
     */
    public lookupSpaceById(requestParameters: SpacesApiLookupSpaceByIdRequest, options?: AxiosRequestConfig) {
        return SpacesApiFp(this.configuration).lookupSpaceById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a variety of information about the Spaces specified by the requested IDs
     * @summary Space lookup up Space IDs
     * @param {SpacesApiLookupSpaceIdsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpacesApiGenerated
     */
    public lookupSpaceIds(requestParameters: SpacesApiLookupSpaceIdsRequest, options?: AxiosRequestConfig) {
        return SpacesApiFp(this.configuration).lookupSpaceIds(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
